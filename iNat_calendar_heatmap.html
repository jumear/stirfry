<!DOCTYPE html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0" />
<meta name="description" content="iNaturalist Observations Calendar Heatmap" />
<title>iNaturalist Observations Calendar Heatmap</title>
<style>
   :root {
      background: var(--color-base);
      color: var(--color-text);
      font: 14px Sans-Serif;
      --color-base: white;
      --color-alt: whitesmoke;
      --color-brand: forestgreen;
      --color-text: black;
      --color-text-invert: white;
      --color-text-link: royalblue;
      --color-border: gray;
      --color-border-minor: white;
      --color-hover: lightgray;
      --color-base-translucent: rgba(255,255,255,0.85);
   }
   @media (prefers-color-scheme: dark) {
      :root {
         --color-base: black;
         --color-alt: #171717;
         --color-brand: forestgreen;
         --color-text: #bababa;
         --color-text-invert: black;
         --color-text-link: cornflowerblue;
         --color-border: #444;
         --color-border-minor: black;
         --color-hover: #444;
         --color-base-translucent: rgba(0,0,0,0.85);
      }
   }
   .year { position:relative; }
   .yearheader { width:100%; text-align:center; position:absolute; padding:2px; font-weight:600; background:var(--color-brand); color:var(--color-text-invert); }
   .yearanchor { position:absolute; }
   .yearcell { border:1px solid var(--color-border-minor); background:var(--color-base); }
   .calendar { position:relative; }
   .dayanchor { position:absolute; }
   .daycell { border:1px solid var(--color-border-minor); }
   .majorbordertop { border-top-color:var(--color-border); }
   .majorborderbottom { border-bottom-color:var(--color-border); }
   .majorborderleft { border-left-color:var(--color-border); }
   .majorborderright { border-right-color:var(--color-border); }
   .maxcount { border-color:red; }
   a:has(.maxcount) { z-index:99999998; }
   a { text-decoration:none; color:var(--color-text-link); }
   a:hover { background:var(--color-hover); }
</style>
</head>

<body>
<script>
let winurlstr = window.location.href;
let winurlsearchstr = window.location.search;
let winurlexsearchstr = winurlstr.replace(winurlsearchstr,'');
let winurlparams = new URLSearchParams(winurlsearchstr.substring(1));
let p_options = winurlparams.get('options') || [];
winurlparams.delete('options');
winurlparams.delete('date_field'); // the page currently handles only observation counts based on observed date
winurlparams.set('interval','day'); // the page currently is designed for only daily counts

// d1 is not specified, default d1 to 9 years before the first day of either d2 (if specified) or the current year (if d2 is not specified)
p_d1 = winurlparams.get('d1');
p_d2 = winurlparams.get('d2');
let effective_d2 = p_d2 ? new Date(p_d2) : new Date();
let default_d1 = new Date(effective_d2.getFullYear()-9,0,1);
if (!p_d1) { winurlparams.set('d1',fyyyymmdd(default_d1)); };

function furl(url,txt=url) { return `<a href="${url}">${txt}</a>`; };
function famp(str) { return str.replace(/&/g,'&amp;'); };
function fcomnum(n) { return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g,',') };
function faddelem(etype,eparent=null,eattributes={}) {
   let eobj = document.createElement(etype);
   for (let [key,value] of Object.entries(eattributes)) {
      if ( typeof value === 'object' && value !== null ) {
         for (let [subkey,subvalue] of Object.entries(value)) { eobj[key][subkey] = subvalue; };
      }
      else { eobj[key] = value; };
    };
   if (eparent) { eparent.appendChild(eobj); };
   return eobj;
};
function faddelems(etype,eparent=null,eattributes=[]) { for (let e of eattributes) { faddelem(etype,eparent,e); }; };
function fyyyymmdd(date) {
    let year = date.getFullYear();
    let month = String(date.getMonth()+1).padStart(2,'0');
    let day = String(date.getDate()).padStart(2,'0');
    return `${year}-${month}-${day}`;
};
function fyear(year,parent=document.body,xshift=0) {
   // get first day and last day of year, and create an array that contains all days in the year
   let firstday = new Date(year,0,1);
   let lastday = new Date(year,11,31);
   let day = new Date(firstday);
   let days = [];
   while (day.getTime() <= lastday.getTime()) { 
      days.push(new Date(day));
      day.setDate(day.getDate() + 1);
   };
   // determine the position of each day in the calendar timeline, and determine whether any of the borders of each cell are major borders
   days.sort(function(a, b) { return a.getDay()-b.getDay(); }); // group days by day of week
   let yshift = 1;
   let ypos = 0;
   let dayformat = {};
   function fmajorborder(df,border) {
      if (df?.borders) { if (!df.borders.includes(border)) { df.borders.push(border) }; }
      else { df.borders = [border]; };
   };
   for (let i = 0; i < days.length; i++) {
      day = days[i];
      df = dayformat[fyyyymmdd(day)] = {};
      if (i === 0 || days[i-1].getDay() < day.getDay()) {
         ypos = 0;
         if (day.getTime() == firstday.getTime()) { yshift = 0; };
         fmajorborder(df,'top');
      };
      if (i === 0 || days[i-1].getMonth() < day.getMonth()) { fmajorborder(df,'top'); };
      if (day.getDay() === 0 || day.getDate() === 1) { fmajorborder(df,'left'); };
      if ( i + 1 === days.length || day.getDay() <  days[i+1].getDay() ) { fmajorborder(df,'bottom'); };
      if ( day.getDay() === 6 || day.getTime() === lastday.getTime() ) { fmajorborder(df,'right'); };
      df.xpos = day.getDay();
      df.ypos = ypos + yshift;
      ypos++;
   };
   // create the base calendar structure
   let cellsize = 12;
   let cellborder = 1;
   divyear = faddelem('div',parent,{id:`div${String(year)}`,classList:'year',style:{width:`${(cellsize+1)*7}px`,left:`${xshift}px`}});
   divhdr = faddelem('div',divyear,{innerText:String(year),classList:'yearheader'});
   yearanchor = faddelem('a',divhdr,{classList:'yearanchor',style:{top:'3px',left:'4px'}});
   yearcell = faddelem('div',yearanchor,{id:String(year),title:String(year),classList:'yearcell',value:0,days:0,style:{width:`${cellsize}px`,height:`${cellsize}px`}});
   divcal = faddelem('div',divyear,{classList:'calendar',style:{top:`${divhdr.clientHeight+8}px`}});
   days.sort((a, b)=>a-b); // rearrange days to original order (ascending)
   const daystext = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
   for (let day of days) {
      df = dayformat[fyyyymmdd(day)];
      dayanchor = faddelem('a',divcal,{classList:'dayanchor',style:{left:`${df.xpos*(cellsize+cellborder)}px`,top:`${df.ypos*(cellsize+cellborder)}px`}});
      daycell = faddelem('div',dayanchor,{id:fyyyymmdd(day),title:`${fyyyymmdd(day)} (${daystext[day.getDay()]})`,classList:['daycell',...(df?.borders??[]).map(t=>'majorborder'+t)].join(' '),style:{width:`${cellsize}px`,height:`${cellsize}px`}});
   };
   return divyear;
};
function fyears(years=[]) {
   divyears = faddelem('div',document.body,{id:'divyears',style:{position:'relative'}});
   xspacing = 16;
   xshift = 0;
   for (year of years) {
      divyear = fyear(year,divyears,xshift);
      xshift = divyear.offsetLeft + divyear.offsetWidth + xspacing;
   };
};
function fresults(data) {
   let results = data?.results?.day ?? {};
   let days = Object.keys(results) ?? [];
   if (days.length === 0) {
      faddelem('p',document.body,{innerText:'No results found for these parameters.'});
      return;
   };
   // based on the results returned, determine which years to visualize, count days with observations and sum observation counts by year, and get max observation counts across all days and all years
   let years = [];
   let maxyears = 15;
   let maxvalue = {day:0, year:0};
   let counts = {};
   days.sort();
   for (let i=days.length; i>0; i--) {
      day = days[i-1];
      count = counts[String(day)] = {};
      let value = count.obs = results[day];
      if (maxvalue.day < value) { maxvalue.day = value; };
      year = parseInt(day.substring(0,4));
      if (!years.includes(year)) {
         if (years.length >= maxyears) { break; };
         years.push(year);
         counts[String(year)] = {obs:0, dayswobs:0};
      };
      if (value>0) {
         counts[String(year)].obs+=value;
         counts[String(year)].dayswobs++;
      };
   };
   // create the base calendar structures
   years.sort();
   fyears(years);
   // format the day and year cells
   function fsetcellcolorandlink(id,mode='day') {
      let maxobscount = (mode === 'year') ? maxvalue.year : maxvalue.day;
      let count = counts[id];
      let cell = document.getElementById(id);
      cell.value = count.obs;
      cell.title += `\nobs: ${fcomnum(count.obs)}`;
      if (mode==='year') {
         cell.daysWithObs = count.dayswobs
         cell.title += `\ndays w/obs: ${count.dayswobs}`;
      };
      if (count.obs>0) {
         cell.style.background = (window.matchMedia('(prefers-color-scheme: dark)').matches) // choose algorithm based on dark mode setting
            ? `hsl(120,${maxobscount?count.obs/maxobscount*100:0}%,${maxvalue?(10+(count.obs/maxobscount*70)):0}%`
            : `hsl(120,${maxobscount?count.obs/maxobscount*100:0}%,${maxvalue?(90-(count.obs/maxobscount*70)):100}%`;
         if (maxobscount===count.obs) { cell.classList.add('maxcount'); };
         params = new URLSearchParams(winurlparams);
         params.set((mode==='year')?'year':'on',cell.id);
         params.set('per_page',200);
         params.delete('interval');
         cell.parentElement.href = `https://jumear.github.io/stirfry/iNatAPIv1_observations?${params}`;
      };
   };
   for (let i=days.length; i>0; i--) {
      day = days[i-1];
      if (!years.includes(parseInt(day.substring(0,4)))) { break; };
      fsetcellcolorandlink(day);
   };
   for (year of years) {
      value = counts[String(year)].obs;
      if (maxvalue.year<value) { maxvalue.year = value; };
   };
   for (year of years) { fsetcellcolorandlink(year,'year'); };
};

let apibase = 'https://api.inaturalist.org/v1/observations/histogram';
let apiurl = apibase+((winurlparams!='')?('?'+winurlparams):'');
let apirefurl = 'https://api.inaturalist.org/v1/docs/#!/Observations/get_observations_histogram';
let apirefname = 'iNaturalist Observations Histogram';
let apiref = furl(apirefurl,apirefname);
faddelem('h1',document.body,{innerText:document.title});
if (winurlsearchstr==='') {
   let instructions = [
      {innerHTML:'This page displays the response from the '+apiref+' API endpoint in a calendar heatmap visualization. To use this page, add at least one query parameter to the URL. See '+furl(apirefurl)+' for available query parameters.'},
      {innerHTML:'Suppose the address of this page is '+winurlexsearchstr+', and you want to see the results of '+furl(famp(apibase+'?user_id=pisum&interval=day&d1=2020-01-01'))+' in a calendar heatmap visualization, then you would open '+furl(famp(winurlexsearchstr+'?user_id=pisum&interval=day&d1=2020-01-01'))+' in your browser.'},
      {innerText:`Note that the page will force interval=day and date_field=observed as parameters when retrieving data. Additionally, if you don't specify a d1 parameter, the API will retrieve only a limited number of days. So in an attempt to get a larger set of data than the API would otherwise deliver when d1 is not specified, the page will automatically apply a parameter d1=[9 years prior to the first day of either d2 or the current year] when requesting data. The page will also limit the visualization to 15 years max, even if the API returns more data than that.`},
      {innerText:`You can click on the cells to see the underlying observations for the day. You can also mouseover a cell to see the date and observation count. The cell(s) with the highest count in the set will have a red border.`},
   ];
   faddelems('p',document.body,instructions);
}
else {
   faddelem('p',document.body,{innerHTML:'This is the base query: '+furl(famp(apiurl))+' ['+furl('https://jumear.github.io/stirfry/iNatAPIv1_observation_histogram?'+winurlparams,'chart + table')+']. (This page will accept most parameters from the '+apiref+' API endpoint.)'});
   fetch(apiurl)
   .then((response) => {
      if (!response.ok) { throw new Error(response.status+' ('+response.statusText+') returned from '+response.url); };
      return response.json();
   })
   .then((data) => { fresults(data); })
   .catch((err) => {
      console.error(err.message);
      faddelem('p',document.body,{innerText:'There was a problem retrieving data. Error '+err.message+'.'});
   });
};
</script>
</body>

</html>