<!DOCTYPE html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="iNaturalist Map Observation Interaction Area Visualization" />
<title>iNaturalist Map Observation Interaction Area Visualization</title>
<style>
   body { height:100vh; width:100vw; margin:0px; }
   #nav { font:9pt Sans-serif; height:100vh; width:25vw; position:absolute; top:0vh; left:0vw; background:darkgray; }
   #mapid { height:100vh; width:75vw; position:absolute; top:0vh; left:25vw; background:darkgray; }
   p { margin:10px 10px 0px 10px; }
</style>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin="" />
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>

<script>

// debug grid example from https://leafletjs.com/examples/extending/extending-2-layers.html
L.GridLayer.DebugCoords = L.GridLayer.extend({
   createTile: function (coords) {
      var tile = document.createElement('div');
      tile.innerHTML = [coords.x, coords.y, coords.z].join(', ');
      tile.style.outline = '1px solid red';
      return tile;
   }
});
L.gridLayer.debugCoords = function(opts) {
   return new L.GridLayer.DebugCoords(opts);
};

// iNaturalist UTFGrid Density Map
function freplacexyz(url,x,y,z) {
   url = url.replace('{x}',x);
   url = url.replace('{y}',y);
   url = url.replace('{z}',z);
   return url;
};
L.GridLayer.UTFGridDensityMap = L.GridLayer.extend({
   createTile: function (coords, done) {

      var tile = document.createElement('canvas');
      var tileSize = this.getTileSize();
      tile.width = tileSize.x;
      tile.height = tileSize.y;
      var cellsPerTile = {x:64,y:64};
      var cellSize = {x:tileSize.x/cellsPerTile.x,y:tileSize.y/cellsPerTile.y};
      var ctx = tile.getContext('2d');

      // default marker setups
      var dmarker = {size:0.75,offset:{x:0,y:0},colorRGB:[0,255,0]};
      var marker = null;
      if (this.options.marker) {
         marker = this.options.marker;
         marker.size = marker.size || dmarker.size;
         marker.offset = marker.offset || dmarker.offset;
         marker.offset.x = marker.offset.x || dmarker.offset.x;
         marker.offset.y = marker.offset.y || dmarker.offset.y;
         marker.colorRGB = marker.colorRGB || dmarker.colorRGB;
      }
      else { marker = dmarker };
      var offset = marker.offset;

      // get UTFgrid
      var url = freplacexyz(this.options.url,coords.x,coords.y,coords.z);
      fetch(url)
      .then((response) => {
         if (!response.ok) { throw new Error(response.status+': '+response.statusText); };
         return response.json();
      })
      // draw markers on a canvas object
      .then((utfgrid) => {
         //draw markers on the tile canvas
         for (cx=0;cx<cellsPerTile.x;cx++) {
            for (cy=0;cy<cellsPerTile.y;cy++) {
               var cell = {x:cx,y:cy};
               //for details about decoding the UTFgrid, see https://github.com/mapbox/utfgrid-spec/blob/master/1.2/utfgrid.md
               var i = utfgrid.grid[cell.y].charCodeAt(cell.x);
               i = i-((i>=93)?34:(i>=35)?33:32);
               var d = utfgrid.data[utfgrid.keys[i]];
               var markerColor = 0; //default to black
               if (d!=null) {
                  var opacity = 0.5;
                  var markerColor = 'rgba('+marker.colorRGB+','+opacity+')'; //rgba format
                  ctx.fillStyle = markerColor;
                  ctx.fillRect(cell.x*cellSize.x+offset.x,cell.y*cellSize.y+offset.y,cellSize.x*marker.size,cellSize.y*marker.size);
               };
            };
         };
      })
      .catch((err) => { console.error(err); });

      // asynchronous call
      setTimeout(function() {
         done(null, tile);
      }, 1000);
      return tile;
   }
});
L.gridLayer.utfGridDensityMap = function (options) {
   return new L.GridLayer.UTFGridDensityMap(options);
};

/*
https://github.com/mapbox/corslite
BSD 2-Clause License

Copyright (c) 2017, Mapbox
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

function corslite(url, callback, cors) {
    var sent = false;

    if (typeof window.XMLHttpRequest === 'undefined') {
        return callback(Error('Browser not supported'));
    }

    if (typeof cors === 'undefined') {
        var m = url.match(/^\s*https?:\/\/[^\/]*/);
        cors = m && (m[0] !== location.protocol + '//' + location.hostname +
                (location.port ? ':' + location.port : ''));
    }

    var x = new window.XMLHttpRequest();

    function isSuccessful(status) {
        return status >= 200 && status < 300 || status === 304;
    }

    if (cors && !('withCredentials' in x)) {
        // IE8-9
        x = new window.XDomainRequest();

        // Ensure callback is never called synchronously, i.e., before
        // x.send() returns (this has been observed in the wild).
        // See https://github.com/mapbox/mapbox.js/issues/472
        var original = callback;
        callback = function() {
            if (sent) {
                original.apply(this, arguments);
            } else {
                var that = this, args = arguments;
                setTimeout(function() {
                    original.apply(that, args);
                }, 0);
            }
        }
    }

    function loaded() {
        if (
            // XDomainRequest
            x.status === undefined ||
            // modern browsers
            isSuccessful(x.status)) callback.call(x, null, x);
        else callback.call(x, x, null);
    }

    // Both `onreadystatechange` and `onload` can fire. `onreadystatechange`
    // has [been supported for longer](http://stackoverflow.com/a/9181508/229001).
    if ('onload' in x) {
        x.onload = loaded;
    } else {
        x.onreadystatechange = function readystate() {
            if (x.readyState === 4) {
                loaded();
            }
        };
    }

    // Call the callback with the XMLHttpRequest object as an error and prevent
    // it from ever being called again by reassigning it to `noop`
    x.onerror = function error(evt) {
        // XDomainRequest provides no evt parameter
        callback.call(this, evt || true, null);
        callback = function() { };
    };

    // IE9 must have onprogress be set to a unique function.
    x.onprogress = function() { };

    x.ontimeout = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };

    x.onabort = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };

    // GET is the only supported HTTP Verb by XDomainRequest and is the
    // only one supported here.
    x.open('GET', url, true);

    // Send the request. Sending data is not supported.
    x.send(null);
    sent = true;

    return x;
}

if (typeof module !== 'undefined') module.exports = corslite;

/*
https://github.com/consbio/Leaflet.UTFGrid/blob/master/L.UTFGrid.js
Copyright (c) 2015 - 2017, Conservation Biology Institute

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

//heavily modified from: https://raw.githubusercontent.com/danzel/Leaflet.utfgrid/leaflet-master/src/leaflet.utfgrid.js
//depends on corslite

L.UTFGrid = L.TileLayer.extend({
	options: {
		resolution: 4,
		pointerCursor: true,
        mouseInterval: 66  // Delay for mousemove events
	},

	_mouseOn: null,
    _mouseOnTile: null,
    _tileCharCode: null, // '<tileKey>:<charCode>' or null
    _cache: null, // {<tileKey>: <utfgrid>}
    _idIndex: null, // {<featureID>: {<tileKey1>: true, ...<tileKeyN>: true} }
    _throttleMove: null, // holds throttled mousemove handler
    //_throttleConnectEventHandlers: null, // holds throttled connection setup function

    _updateCursor: function(){ }, //no-op, overridden below

	onAdd: function (map) {
        this._cache = {};
        this._idIndex = {};

        L.TileLayer.prototype.onAdd.call(this, map);

        this._throttleMove = L.Util.throttle(this._move, this.options.mouseInterval, this);

        if (this.options.pointerCursor) {
            this._updateCursor = function(cursor) { this._container.style.cursor = cursor; }
        }

        map.on('boxzoomstart', this._disconnectMapEventHandlers, this);
        // have to throttle or we get an immediate click event on boxzoomend
        map.on('boxzoomend', this._throttleConnectEventHandlers, this);
        this._connectMapEventHandlers();
	},

	onRemove: function () {
		var map = this._map;
        map.off('boxzoomstart', this._disconnectMapEventHandlers, this);
        map.off('boxzoomend', this._throttleConnectEventHandlers, this);
        this._disconnectMapEventHandlers();
		this._updateCursor('');
        L.TileLayer.prototype.onRemove.call(this, map);
	},

    createTile: function(coords) {
        this._loadTile(coords);
        return document.createElement('div');  // empty DOM node, required because this overrides L.TileLayer
	},

    setUrl: function(url, noRedraw) {
        this._cache = {};
        return L.TileLayer.prototype.setUrl.call(this, url, noRedraw);
    },

    _connectMapEventHandlers: function(){
        this._map.on('click', this._onClick, this);
        this._map.on('mousemove', this._throttleMove, this);
    },

    _disconnectMapEventHandlers: function(){
        this._map.off('click', this._onClick, this);
		this._map.off('mousemove', this._throttleMove, this);
    },

    _throttleConnectEventHandlers: function() {
        setTimeout(this._connectMapEventHandlers.bind(this), 100);
    },

    _update: function (center, zoom) {
        L.TileLayer.prototype._update.call(this, center, zoom);
    },

    _loadTile: function (coords) {
        var url = this.getTileUrl(coords);
		var key = this._tileCoordsToKey(coords);
		var self = this;
        if (this._cache[key]) { return }
        corslite(url, function(err, response){
            if (err) {
                self.fire('error', {error: err});
                return;
            }
            var data = JSON.parse(response.responseText);
            self._cache[key] = data;
            L.Util.bind(self._handleTileLoad, self)(key, data);
        }, true);
	},

    _handleTileLoad: function(key, data) {
        // extension point
    },

	_onClick: function (e) {
		this.fire('click', this._objectForEvent(e));
	},

	_move: function (e) {
        if (e.latlng == null){ return }

		var on = this._objectForEvent(e);

        if (on._tileCharCode !== this._tileCharCode) {
			if (this._mouseOn) {
				this.fire('mouseout', {
                    latlng: e.latlng,
                    data: this._mouseOn,
                    _tile: this._mouseOnTile,
                    _tileCharCode: this._tileCharCode
                });
				this._updateCursor('');
			}
			if (on.data) {
				this.fire('mouseover', on);
				this._updateCursor('pointer');
			}

			this._mouseOn = on.data;
            this._mouseOnTile = on._tile;
            this._tileCharCode = on._tileCharCode;
		} else if (on.data) {
			this.fire('mousemove', on);
		}
	},

	_objectForEvent: function (e) {
	    if (!e.latlng) return;  // keyboard <ENTER> events also pass through as click events but don't have latlng

        var map = this._map,
		    point = map.project(e.latlng),
		    tileSize = this.options.tileSize,
		    resolution = this.options.resolution,
		    x = Math.floor(point.x / tileSize),
		    y = Math.floor(point.y / tileSize),
		    gridX = Math.floor((point.x - (x * tileSize)) / resolution),
		    gridY = Math.floor((point.y - (y * tileSize)) / resolution),
			max = map.options.crs.scale(map.getZoom()) / tileSize;

        x = (x + max) % max;
        y = (y + max) % max;

        var tileKey = this._tileCoordsToKey({z: map.getZoom(), x: x, y: y});

		var data = this._cache[tileKey];
		if (!data) {
			return {
                latlng: e.latlng,
                data: null,
                _tile: null,
                _tileCharCode: null
            };
		}

        var charCode = data.grid[gridY].charCodeAt(gridX);
		var idx = this._utfDecode(charCode),
		    key = data.keys[idx],
		    result = data.data[key];

		if (!data.data.hasOwnProperty(key)) {
			result = null;
		}

		return {
            latlng: e.latlng,
            data: result,
            id: (result)? result.id: null,
            _tile: tileKey,
            _tileCharCode: tileKey + ':' + charCode
        };
	},

    _dataForCharCode: function (tileKey, charCode) {
        var data = this._cache[tileKey];
        var idx = this._utfDecode(charCode),
		    key = data.keys[idx],
		    result = data.data[key];

		if (!data.data.hasOwnProperty(key)) {
			result = null;
		}
        return result;
    },

	_utfDecode: function (c) {
		if (c >= 93) {
			c--;
		}
		if (c >= 35) {
			c--;
		}
		return c - 32;
	},

    _utfEncode: function (c) {
        //reverse of above, returns charCode for c
        //derived from: https://github.com/mapbox/glower/blob/mb-pages/src/glower.js#L37
        var charCode = c + 32;
        if (charCode >= 34) {
            charCode ++;
        }
        if (charCode >= 92) {
            charCode ++;
        }
        return charCode;
    }
});

L.utfGrid = function (url, options) {
	return new L.UTFGrid(url, options);
};

L.UTFGridCanvas = L.UTFGrid.extend({
	options: {
        idField: 'ID',  // Expects UTFgrid to have a property 'ID' that indicates the feature ID
        buildIndex: true,  // requires above field to be set properly
        fillColor: 'black',
	    shadowBlur: 0,  // Number of pixels for blur effect
        shadowColor: null,  // Color for shadow, if present.  Defaults to fillColor.
        debug: false  // if true, show tile borders and tile keys
    },

    _adjacentTiles: null,

    onAdd: function (map) {
        this._adjacentTiles = [];

        L.UTFGrid.prototype.onAdd.call(this, map);
	},

    createTile: function(coords) {
        this._loadTile(coords);

        var tile = document.createElement('canvas');
        tile.width = tile.height = this.options.tileSize;

        if (this.options.debug) {
            this._drawDefaultTile(tile.getContext('2d'), this._tileCoordsToKey(coords));
        }

        return tile;
	},

    _connectMapEventHandlers: function(){
        L.UTFGrid.prototype._connectMapEventHandlers.call(this);
        this.on('mouseover', this._handleMouseOver, this);
        this.on('mouseout', this._handleMouseOut, this);
    },

    _disconnectMapEventHandlers: function(){
        L.UTFGrid.prototype._disconnectMapEventHandlers.call(this);
        this.off('mouseover', this._handleMouseOver, this);
        this.off('mouseout', this._handleMouseOut, this);
    },

    _handleMouseOver: function (e) {
        if (e._tile == null || e._tileCharCode == null){ return }

        this._clearAdjacentTiles();

        // currently over this tile:
        var curTile = e._tile;
        this._drawTile(curTile, parseInt(e._tileCharCode.split(':')[3]));

        if (e.data && this._idIndex) {
            // draw adjacent tiles
            var id = e.data[this.options.idField];
            var zoomLevel = curTile.split(':')[2];
            if (!(id && this._idIndex[id] && this._idIndex[id][zoomLevel])) { return }

            var idx = this._idIndex[id][zoomLevel];
            for (var tileKey in idx) {
                //TODO: screen out any tiles that are not currently visible?
                if (tileKey !== curTile) {
                    this._drawTile(tileKey, idx[tileKey]);
                    this._adjacentTiles.push(tileKey);
                }
            }
        }
    },

    _handleMouseOut: function (e) {
        this._resetTile(e._tile);
        this._clearAdjacentTiles();
    },

    _clearAdjacentTiles: function() {
        // clear out any adjacent tiles that were drawn
        if (this._adjacentTiles) {
            for (var i = 0; i < this._adjacentTiles.length; i++) {
                this._resetTile(this._adjacentTiles[i]);
            }
            this._adjacentTiles = [];
        }
    },

    _handleTileLoad: function(tileKey, data) {
        // build index: {<id: {zoomLevel: {tileKey: tileCharCode} } }
        if (this.options.buildIndex) {
            var id, props, idx;
            var idField = this.options.idField;
            var zoomLevel = tileKey.split(':')[2];
            for (var i = 0; i < data.keys.length; i++) {
                props = data.data[data.keys[i]];
                if (props) {
                    id = props[idField];
                    if (id) {
                        if (this._idIndex[id] == null) {
                            this._idIndex[id] = {};
                        }
                        idx = this._idIndex[id];
                        if (idx[zoomLevel] == null) {
                            idx[zoomLevel] = {};
                        }
                        idx[zoomLevel][tileKey] = this._utfEncode(i);
                    }
                }
            }
        }
    },

    _drawTile: function(tileKey, charCode) {
        // for a given tile, find all pixels that match character and repaint
        // TODO: request animation frame?

        if (this._tiles[tileKey] == null){ return }

        var canvas = this._tiles[tileKey].el;
        var ctx = canvas.getContext('2d');

        this._resetTile(tileKey);
        var grid = this._cache[tileKey].grid;

        ctx.fillStyle = this.options.fillColor;
        var dim = this.options.tileSize / this.options.resolution;

        // TODO: order of traversal here may be backwards?  Do y then x?  (are data column major or row major?)
        //modified slightly from: https://github.com/mapbox/glower/blob/mb-pages/src/glower.js
        for (var x = 0; x < dim; x++) {
            for (var y = 0; y < dim; y++) {
                if (grid[y].charCodeAt(x) === charCode) {
                    var sweep = 1;
                    while (y < 63 && grid[y + 1].charCodeAt(x) === charCode) {
                        y++;
                        sweep++;
                    }
                    ctx.fillRect(x * 4, (y * 4) - ((sweep - 1) * 4), 4, 4 * sweep);
                }
            }
        }

        if (this.options.shadowBlur) {
            this._addShadow(canvas, ctx);
        }
	
    },

    _resetTile: function(tileKey) {
        // clear the canvas
        if (this._tiles[tileKey] == null){ return }

        var tile = this._tiles[tileKey].el;
        tile.width = this.options.tileSize;  // hard reset of canvas

        if (this.options.debug) {
            this._drawDefaultTile(tile.getContext('2d'), tileKey);
        }
    },

    _drawDefaultTile: function(ctx, tileKey) {
        // if this.options.debug, add tileKey text and borders
        ctx.fillStyle = 'black';
        ctx.fillText(tileKey, 20, 20);
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(255, 0);
        ctx.lineTo(255, 255);
        ctx.lineTo(0, 255);
        ctx.closePath();
        ctx.stroke();
    },

    _addShadow: function(canvas, ctx) {
        ctx.shadowBlur = this.options.shadowBlur;
        ctx.shadowColor = this.options.shadowColor || this.options.fillColor;

        //Blur effect copied from glower - https://github.com/cutting-room-floor/glower/blob/mb-pages/src/glower.js#L108
        ctx.globalAlpha = 0.7;
        ctx.globalCompositeOperation = 'lighter';
        var a = 1;
        ctx.drawImage(canvas, -a, -a);
        ctx.drawImage(canvas, a, a);
        ctx.drawImage(canvas, 0, -a);
        ctx.drawImage(canvas, -a, 0);
        ctx.globalAlpha = 1;
    }
});

L.utfGridCanvas = function (url, options) {
	return new L.UTFGridCanvas(url, options);
};


</script>
</head>
<body>
<div id="nav">
<p>Markers in maps in iNaturalist are generally delivered as tiled image files, not actually as individual markers. This means that a user cannot directly interact with the markers displayed on the maps.</p>
<p>Instead, a user interacts with an invisible UTFgrid layer -- a grid of square cells -- that sits on top of the marker layer. The idea is that if a user interacts with a UTFgrid cell that is positioned on top of a particular marker, then the action triggered should correspond to an action meaningful for that marker.</p>
<p>The UTFgrid cells do not always approximate the shape of their corresponding markers correctly. This page provides a way to visualize the areas where an interaction can take place, alongside the corresponding markers that would be shown on an iNaturalist map.</p>
<p>A few notes:</p>
<p>First, this page uses a different set of basemaps than those available in iNaturalist (since the ones that iNaturalist uses are not free).</p>
<p>Second, I *think* the iNaturalist maps do some sort of fancy offset for the pin-style markers (the ones that look like upside down teardrops) so that their corresponding interaction areas are effectively shifted up a bit. (The effect would be that the corresponding interaction area in iNaturalist would be the fat end of a pin vs the narrow tip of a pin in this page.) Since this page does not do any fancy offsetting, you will just have to mentally do the shift to imagine where you would need to hover and click on an iNaturalist map.</p>
<p>Finally, the set of observations displayed by this page can be modified by adding parameters to the page URL. For example, if you would to see just bird observations by loarie, you could add "?user_id=loarie&taxon_id=3" to the end of the base URL. See the API reference for the <a href="https://api.inaturalist.org/v1/docs/#!/Observations/get_observations">Get Observations endpoint</a> for a full list of parameters available to use.</p>
</div>
<div id="mapid"></div>

<script>
function fdate(str) {
   str = str.replace(/t/i,' '); //replaces T (case insensitive) with a space
   str = str.replace(/([+-]\d{2}\:?\d{2})/,' ($1)'); //puts parenthesis around time zone offset
   str = str.replace(/z/i,' (+00:00)'); //replaces Z (case insensitve) with UTC
   str = str.replace('+00:00','Â±00:00');
   return str;
};
function fround(num,places) {
   var n = num*1;
   return n.toFixed(places); 
};

//get parameters from the url
let winurlstr = window.location.href;
let winurlsearchstr = window.location.search;
let winurlexsearchstr = winurlstr.replace(winurlsearchstr,'');
let winurlparams = new URLSearchParams(winurlsearchstr.substring(1));
var taxon_id = winurlparams.get('taxon_id');
taxon_id = (taxon_id===null?null:taxon_id.split(',')[0]);
var place_id = winurlparams.get('place_id');
place_id = (place_id===null?null:place_id.split(',')[0]);
var scale_factor = winurlparams.get('scale_factor');
if (scale_factor) {
   var sfarray = scale_factor.split(',');
   for (sf=1;sf<6;sf++) { if (sfarray.length<=sf) {sfarray.push(sfarray[sf-1]);}; };
};
var centerlat = winurlparams.get('centerlat') || 0;
var centerlng = winurlparams.get('centerlng') || 0;
var defaultzoom = winurlparams.get('defaultzoom') || 2;
var defaultstyle = winurlparams.get('defaultstyle') || 'opacity';
var hideleftpane = winurlparams.get('hideleftpane') || 'false';
var showtaxonplace = winurlparams.get('showtaxonplace') || 'false';
var showtaxonrange = winurlparams.get('showtaxonrange') || 'false';
var showplace = winurlparams.get('showplace') || 'false';

if (hideleftpane==='true') {
   var mapdiv = document.getElementById('mapid');
   mapdiv.style.left = '0vw';
   mapdiv.style.width = '100vw';
   var navdiv = document.getElementById('nav');
   navdiv.style.visibility = 'hidden';
};

winurlparams.delete('scale_factor');
winurlparams.delete('centerlat');
winurlparams.delete('centerlng');
winurlparams.delete('defaultzoom');
winurlparams.delete('defaultstyle');
winurlparams.delete('hideleftpane');
winurlparams.delete('showtaxonplace');
winurlparams.delete('showtaxonrange');
winurlparams.delete('showplace');

// iNat UTFGrid Visualization, using grid-style UTFGrid at lower zooms and point-style UTFGrid at higher zooms
let utfgridapi_grid = {url:'https://api.inaturalist.org/v1/grid/{z}/{x}/{y}.grid.json',attr:'<a href="https://api.inaturalist.org/v1/docs/#!/UTFGrid/get_grid_zoom_x_y_grid_json">iNaturalist</a>'};
let utfgridapi_points = {url:'https://api.inaturalist.org/v1/points/{z}/{x}/{y}.grid.json',attr:'<a href="https://api.inaturalist.org/v1/docs/#!/UTFGrid/get_points_zoom_x_y_grid_json">iNaturalist</a>'};
var l_utfgdm1 = L.gridLayer.utfGridDensityMap({url:utfgridapi_grid.url+'?'+winurlparams,minZoom:0,maxZoom:9,attribution:utfgridapi_grid.attr,marker:{size:0.90,colorRGB:[0,255,0]}})
var l_utfgdm2 = L.gridLayer.utfGridDensityMap({url:utfgridapi_points.url+'?'+winurlparams,minZoom:10,maxZoom:20,attribution:utfgridapi_grid.attr,marker:{size:0.90,colorRGB:[176,0,176]}})
var g_utfgdm = L.layerGroup([l_utfgdm1,l_utfgdm2]);

// iNat Observation Layer, using grid markers at lower zooms and points at higher zooms
let inat_urlbase = 'https://api.inaturalist.org/v1/';
//let inat_circles = {url:inat_urlbase+'colored_heatmap/{z}/{x}/{y}.png',description:'iNaturalist Observations (Density Circles)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_colored_heatmap_zoom_x_y_png">iNaturalist observation data</a>'};
//let inat_heat = {url:inat_urlbase+'heatmap/{z}/{x}/{y}.png',description:'iNaturalist Observations (Heatmap)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_heatmap_zoom_x_y_png">iNaturalist observation data</a>'};
//let gbif_density_point_py = {url:'https://api.gbif.org/v2/map/occurrence/density/{z}/{x}/{y}@1x.png?srs=EPSG:3857&style=purpleYellow.point&publishingOrg=28eb1a3f-1c15-4a95-931a-4af90ecb574d',description:'iNaturalist Observations in GBIF',attribution:'<a href="https://www.gbif.org/developer/maps">GBIF occurrence data</a>'};
//var l_inat_circles = L.tileLayer(inat_circles.url+'?'+winurlparams,{maxZoom:20,attribution:inat_circles.attribution});
//var l_inat_heat = L.tileLayer(inat_heat.url+'?'+winurlparams,{maxZoom:20, attribution:inat_heat.attribution});
//var l_gbif = L.tileLayer(gbif_density_point_py.url,{maxZoom:20, attribution:gbif_density_point_py.attribution});
let inat_points = {url:inat_urlbase+'points/{z}/{x}/{y}.png',description:'iNaturalist Observations (Points)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_points_zoom_x_y_png">iNaturalist observation data</a>'};
let inat_grid = {url:inat_urlbase+'grid/{z}/{x}/{y}.png',description:'iNaturalist Observations (Grid)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_grid_zoom_x_y_png">iNaturalist observation data</a>'};
var l_inat_points = L.tileLayer(inat_points.url+'?'+winurlparams,{minZoom:10,maxZoom:20, attribution:inat_points.attribution});
var l_inat_grid = L.tileLayer(inat_grid.url+'?'+winurlparams,{minZoom:0,maxZoom:9,attribution:inat_grid.attribution});
var g_inat_obs = L.layerGroup([l_inat_grid,l_inat_points]);

// iNat UTFGrid Selection
// (hover to see selected area, and click to view selected observation)
function fpopup(obs) {
   var s = (obs.photos.length==0) ? '[No Photo]' : '<img src="'+obs.photos[0].url+'" />';
   s += (obs.photos.length>1) ? ' ['+obs.photos.length+']' : '';
   s += '<br />observation #: <a target="_blank" href="'+obs.uri+'">'+obs.id+'</a> (grade: '+obs.quality_grade+')';
   s += '<br />taxon: ' + ((obs.taxon==null) ? '[Unknown]' : obs.taxon.preferred_common_name ? (obs.taxon.preferred_common_name+' ('+obs.taxon.name+')') : obs.taxon.name );
   s += '<br />observer: '+obs.user.login;
//   s += '<br />location: '+obs.place_guess;
   s += '<br />coordinates: '+fround(obs.geojson.coordinates[1],6)+', '+fround(obs.geojson.coordinates[0],6);
   s += (obs.positional_accuracy==null) ? '' : ' ('+fround(obs.positional_accuracy,1)+'m)';
   s += '<br />observed: '+((obs.time_observed_at==null) ? ((obs.observed_on==null) ? '[Unknown]': obs.observed_on) : fdate(obs.time_observed_at));
   s += '<br />created: '+((obs.created_at==null) ? obs.created_at_details.date : fdate(obs.created_at));
   s += '<br />last updated: '+fdate(obs.updated_at);
//   if (obs.description==null) {}
//   else if (obs.description.length < 200) {s += '<br />'+obs.description }
//   else {s += '<br />'+(obs.description.substring(0,191)+'... (more)')};
   L.popup().setLatLng([obs.geojson.coordinates[1],obs.geojson.coordinates[0]])
      .setContent(s).openOn(mymap);
};

var u_inat_points = L.utfGrid(inat_urlbase+'points/{z}/{x}/{y}.grid.json'+winurlsearchstr, {
    resolution: 4,
    pointerCursor: true,
    mouseInterval: 66,  // Delay for mousemove events
    minZoom:10,
    maxZoom:20, 
});
u_inat_points.on("click", function(e) { // "mouseover" and "mouseout" events not used here
   if (e.data) {
      corslite(inat_urlbase+'observations/'+e.data.id, function(err, response) {
         if (err) {
            self.fire('error', {error: err});
            return;
         };
         var obsdata = JSON.parse(response.responseText);
         fpopup(obsdata.results[0]);
       }, true);
   };
});

var u_inat_grid = L.utfGrid(inat_urlbase+'grid/{z}/{x}/{y}.grid.json'+winurlsearchstr, {
    resolution: 4,
    pointerCursor: true,
    mouseInterval: 66,  // Delay for mousemove events
    minZoom:0,
    maxZoom:9,
});
u_inat_grid.on("click", function(e) { // "mouseover" and "mouseout" events not used here
   if (e.data) {
      corslite(inat_urlbase+'observations/'+e.data.id, function(err, response) {
         if (err) {
            self.fire('error', {error: err});
            return;
         };
         var obsdata = JSON.parse(response.responseText);
         fpopup(obsdata.results[0]);
       }, true);
   };
});

var v_inat_points = L.utfGridCanvas(inat_urlbase+'points/{z}/{x}/{y}.grid.json'+winurlsearchstr, {
    idField: 'id',  // Expects UTFgrid to have a property 'ID' that indicates the feature ID
    buildIndex: true,  // requires above field to be set properly
    fillColor: 'black',
    shadowBlur: 0,  // Number of pixels for blur effect
    shadowColor: null,  // Color for shadow, if present.  Defaults to fillColor.
    debug: false,  // if true, show tile borders and tile keys
    minZoom:10,
    maxZoom:20, 
});

var v_inat_grid = L.utfGridCanvas(inat_urlbase+'grid/{z}/{x}/{y}.grid.json'+winurlsearchstr, {
    idField: 'id',  // Expects UTFgrid to have a property 'ID' that indicates the feature ID
    buildIndex: true,  // requires above field to be set properly
    fillColor: 'black',
    shadowBlur: 0,  // Number of pixels for blur effect
    shadowColor: null,  // Color for shadow, if present.  Defaults to fillColor.
    debug: false,  // if true, show tile borders and tile keys
    minZoom:0,
    maxZoom:9,
});

var g_utfgdm_sel = L.layerGroup([u_inat_grid,u_inat_points,v_inat_grid,v_inat_points]);


// Other iNaturalist Layers
var l_inat_place = L.tileLayer(inat_urlbase+'places/'+place_id+'/{z}/{x}/{y}.png',{maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_places_place_id_zoom_x_y_png">iNaturalist place polygon</a>'});
/*
// iNaturalist Taxon Places Checklist and Range Layers
var l_inat_taxonplace = L.tileLayer(inat_urlbase+'taxon_places/'+taxon_id+'/{z}/{x}/{y}.png',{maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_taxon_places_taxon_id_zoom_x_y_png">iNaturalist taxon place checklist data</a>'});
var l_inat_taxonrange = L.tileLayer(inat_urlbase+'taxon_ranges/'+taxon_id+'/{z}/{x}/{y}.png',{maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_taxon_ranges_taxon_id_zoom_x_y_png">iNaturalist taxon range data</a>'});
*/

// Stamen layers
var s_stamen_copyright = 'Map tiles by <a href="https://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://www.openstreetmap.org/copyright">ODbL</a>.'; // used for all sets except Watercolor
var s_stamen_urlbase = 'https://stamen-tiles-{s}.a.ssl.fastly.net/';
var l_stamen_watercolor = L.tileLayer(s_stamen_urlbase+'watercolor/{z}/{x}/{y}.jpg',{maxZoom:20, attribution:'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'});
var l_stamen_terrain = L.tileLayer(s_stamen_urlbase+'terrain/{z}/{x}/{y}.jpg',{maxNativeZoom:16, attribution:s_stamen_copyright});
var l_stamen_terrainbg = L.tileLayer(s_stamen_urlbase+'terrain-background/{z}/{x}/{y}.jpg',{maxNativeZoom:16, attribution:s_stamen_copyright});
var l_stamen_terrainlines = L.tileLayer(s_stamen_urlbase+'terrain-lines/{z}/{x}/{y}.jpg',{maxNativeZoom:16, attribution:s_stamen_copyright});
var l_stamen_terrainlabels = L.tileLayer(s_stamen_urlbase+'terrain-labels/{z}/{x}/{y}.jpg',{maxNativeZoom:16, attribution:s_stamen_copyright});
var l_stamen_toner = L.tileLayer(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{maxZoom:20, attribution:s_stamen_copyright});
var l_stamen_tonerlite = L.tileLayer(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{maxZoom:20, attribution:s_stamen_copyright});
var l_stamen_tonerbg = L.tileLayer(s_stamen_urlbase+'toner-background/{z}/{x}/{y}.png',{maxZoom:20, attribution:s_stamen_copyright});
var l_stamen_tonerhybrid = L.tileLayer(s_stamen_urlbase+'toner-hybrid/{z}/{x}/{y}.png',{maxZoom:20, attribution:s_stamen_copyright});
var l_stamen_tonerlines = L.tileLayer(s_stamen_urlbase+'toner-lines/{z}/{x}/{y}.png',{maxZoom:20, attribution:s_stamen_copyright});
var l_stamen_tonerlabels = L.tileLayer(s_stamen_urlbase+'toner-labels/{z}/{x}/{y}.png',{maxZoom:20, attribution:s_stamen_copyright});

// OpenStreetMaps & OpenTopoMap
var l_osm_fr = L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {maxZoom:20, attribution:'donn&eacute;es &copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - rendu <a href="https://openstreetmap.fr">OSM France</a>'});
var l_osm_hot = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {maxZoom:19, attribution:'donn&eacute;es &copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - Tiles courtesy of <a href="https://hot.openstreetmap.org/">Humanitarian OpenStreetMap Team</a>'});
var l_otm = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',{maxNativeZoom:17, attribution:'Kartendaten: &copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap</a>-Mitwirkende, SRTM | Kartendarstellung: &copy; <a href="http://opentopomap.org/">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'});

//debug layer
var l_debug = L.gridLayer.debugCoords();

var defaultlayers = [l_stamen_tonerlite];
/*
if (taxon_id!==null) {
   if (showtaxonplace==='true') {defaultlayers.push(l_inat_taxonplace)};
   if (showtaxonrange==='true') {defaultlayers.push(l_inat_taxonrange)};
};
*/
if (place_id!==null) { 
   if (showplace==='true') {defaultlayers.push(l_inat_place)};
};
defaultlayers.push(g_inat_obs);
defaultlayers.push(g_utfgdm);
defaultlayers.push(g_utfgdm_sel);

// create map, and set default center coordinates, zoom level, and layers
var mymap = L.map('mapid', {
   center: [centerlat,centerlng],
   zoom: defaultzoom,
   layers: defaultlayers,
   doubleClickZoom: false
});

// define available basemaps (can view only one at a time)
var basemaps = {
   "Stamen Watercolor": l_stamen_watercolor,
   "Stamen Terrain": l_stamen_terrain,
   "Stamen Terrain Background": l_stamen_terrainbg,
   "Stamen Toner": l_stamen_toner,
   "Stamen Toner Background": l_stamen_tonerbg,
   "Stamen Toner Lite": l_stamen_tonerlite,
   "OpenTopoMap": l_otm,
   "OpenStreetMap France": l_osm_fr,
   "OpenStreetMap Humanitarian": l_osm_hot,
};

// define available overlay maps (can view more than one at a time, arranged in order from lowest to highest)
var overlaymaps = {
   "Stamen Terrain Lines": l_stamen_terrainlines,
   "Stamen Toner Lines": l_stamen_tonerlines,
   "Stamen Toner Hybrid": l_stamen_tonerhybrid,
   "Stamen Terrain Labels": l_stamen_terrainlabels,
   "Stamen Toner Labels": l_stamen_tonerlabels,
//   "iNaturalist Taxon Range": l_inat_taxonrange,
//   "iNaturalist Taxon Places": l_inat_taxonplace,
   "iNaturalist Place": l_inat_place,
//   "iNaturalist Observations Density in GBIF (no filters)": l_gbif,
//   "iNaturalist Observations Heatmap": l_inat_heat,
//   "iNaturalist Observations Circles": l_inat_circles,
//   "iNaturalist Observations Grid": l_inat_grid,
//   "iNaturalist Observations Points": l_inat_points,
   "iNaturalist Observations":g_inat_obs,
   "iNaturalist Obs Interaction Area":g_utfgdm,
   "iNaturalist Obs Active Interaction":g_utfgdm_sel,
   "Debug Grid":l_debug,
};
/*
if (taxon_id===null) {
   delete overlaymaps["iNaturalist Taxon Range"];
   delete overlaymaps["iNaturalist Taxon Places"];
};
*/
if (place_id===null) {
   delete overlaymaps["iNaturalist Place"];
};

// add a layer selector control and scale bar
L.control.layers(basemaps, overlaymaps).addTo(mymap);
L.control.scale().addTo(mymap);

</script>
</body>
</html>