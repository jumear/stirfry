<!DOCTYPE html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="Map of iNaturalist Observations" />
<title>Map of iNaturalist Observations</title>
<style>
   body { height:100vh; width:100vw; margin:0px; font:10pt Sans-Serif;}
   #mapid { height:100vh; width:100vw; position:absolute; top:0vh; left:0vw; background:darkgray; }
   #info { padding:15px; }
   h1 { margin-top:0px; }
   a { text-decoration:none; }
</style>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>

<script>

// debug grid example from https://leafletjs.com/examples/extending/extending-2-layers.html
L.GridLayer.DebugCoords = L.GridLayer.extend({
   createTile: function (coords) {
      var tile = document.createElement('div');
      tile.innerHTML = [coords.x, coords.y, coords.z].join(', ');
      tile.style.outline = '1px solid red';
      return tile;
   }
});
L.gridLayer.debugCoords = function(opts) {
   return new L.GridLayer.DebugCoords(opts);
};

// this allows a style filter to be applied to a basemap tile layer
L.TileLayer.StyleFilter = L.TileLayer.extend({
   intialize: function (url, options) {
      L.TileLayer.prototype.initialize.call(this, url, options);
   },
   styleFilter: function () {
      var filters = this.options.filter || '';
      return filters;
   },
   _initContainer: function () {
      var tile = L.TileLayer.prototype._initContainer.call(this);
      this._container.style.filter = this.styleFilter();
   },
});
L.tileLayer.styleFilter = function (url, options) {
   return new L.TileLayer.StyleFilter(url, options);
};

// this provides a way to get some USGS map images as tiles, as an alternative to WMS
// primary use case is when the WMS Server doesn't respond very quickly
// but this can also be used for other reasons, such as custom styling of the tiles
L.TileLayer.USGS = L.TileLayer.extend({
   intialize: function (url, options) {
      L.TileLayer.prototype.initialize.call(this, url, options);
   },
   getTileUrl: function (coords) {
      var data = {
         //r: Browser.retina ? '@2x' : '',
         //s: this._getSubdomain(coords),
         x: coords.x,
         y: coords.y,
         z: this._getZoomForUrl()
      };
      let mMax = 20037508.3428;
      let mTile = 2*mMax/(Math.pow(2,data.z));
      let bb = [
         data.x*mTile-mMax,
         -(data.y+1)*mTile+mMax,
         (data.x+1)*mTile-mMax,
         -data.y*mTile+mMax,
      ];
      data['p'] = `&f=image&bboxSR=102100&imageSR=102100&size=${this._tileSize.x},${this._tileSize.y}&bbox=${bb[0]},${bb[1]},${bb[2]},${bb[3]}`;
      return this._url + data.p;
      //return Util.template(this._url, Util.extend(data, this.options));
   },
   styleFilter: function () {
      var filters = this.options.filter || '';
      return filters;
   },
   _initContainer: function () {
      var tile = L.TileLayer.prototype._initContainer.call(this);
      this._container.style.filter = this.styleFilter();
   },
});
L.tileLayer.usgs = function (url, options) {
   return new L.TileLayer.USGS(url, options);
};

/*
https://github.com/mapbox/corslite
BSD 2-Clause License

Copyright (c) 2017, Mapbox
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

function corslite(url, callback, cors) {
    var sent = false;

    if (typeof window.XMLHttpRequest === 'undefined') {
        return callback(Error('Browser not supported'));
    }

    if (typeof cors === 'undefined') {
        var m = url.match(/^\s*https?:\/\/[^\/]*/);
        cors = m && (m[0] !== location.protocol + '//' + location.hostname +
                (location.port ? ':' + location.port : ''));
    }

    var x = new window.XMLHttpRequest();

    function isSuccessful(status) {
        return status >= 200 && status < 300 || status === 304;
    }

    if (cors && !('withCredentials' in x)) {
        // IE8-9
        x = new window.XDomainRequest();

        // Ensure callback is never called synchronously, i.e., before
        // x.send() returns (this has been observed in the wild).
        // See https://github.com/mapbox/mapbox.js/issues/472
        var original = callback;
        callback = function() {
            if (sent) {
                original.apply(this, arguments);
            } else {
                var that = this, args = arguments;
                setTimeout(function() {
                    original.apply(that, args);
                }, 0);
            }
        }
    }

    function loaded() {
        if (
            // XDomainRequest
            x.status === undefined ||
            // modern browsers
            isSuccessful(x.status)) callback.call(x, null, x);
        else callback.call(x, x, null);
    }

    // Both `onreadystatechange` and `onload` can fire. `onreadystatechange`
    // has [been supported for longer](http://stackoverflow.com/a/9181508/229001).
    if ('onload' in x) {
        x.onload = loaded;
    } else {
        x.onreadystatechange = function readystate() {
            if (x.readyState === 4) {
                loaded();
            }
        };
    }

    // Call the callback with the XMLHttpRequest object as an error and prevent
    // it from ever being called again by reassigning it to `noop`
    x.onerror = function error(evt) {
        // XDomainRequest provides no evt parameter
        callback.call(this, evt || true, null);
        callback = function() { };
    };

    // IE9 must have onprogress be set to a unique function.
    x.onprogress = function() { };

    x.ontimeout = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };

    x.onabort = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };

    // GET is the only supported HTTP Verb by XDomainRequest and is the
    // only one supported here.
    x.open('GET', url, true);

    // Send the request. Sending data is not supported.
    x.send(null);
    sent = true;

    return x;
}

if (typeof module !== 'undefined') module.exports = corslite;

/*
https://github.com/consbio/Leaflet.UTFGrid/blob/master/L.UTFGrid.js
Copyright (c) 2015 - 2017, Conservation Biology Institute

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

//heavily modified from: https://raw.githubusercontent.com/danzel/Leaflet.utfgrid/leaflet-master/src/leaflet.utfgrid.js
//depends on corslite

L.UTFGrid = L.TileLayer.extend({
	options: {
		resolution: 4,
		pointerCursor: true,
        mouseInterval: 66  // Delay for mousemove events
	},

	_mouseOn: null,
    _mouseOnTile: null,
    _tileCharCode: null, // '<tileKey>:<charCode>' or null
    _cache: null, // {<tileKey>: <utfgrid>}
    _idIndex: null, // {<featureID>: {<tileKey1>: true, ...<tileKeyN>: true} }
    _throttleMove: null, // holds throttled mousemove handler
    //_throttleConnectEventHandlers: null, // holds throttled connection setup function

    _updateCursor: function(){ }, //no-op, overridden below

	onAdd: function (map) {
        this._cache = {};
        this._idIndex = {};

        L.TileLayer.prototype.onAdd.call(this, map);

        this._throttleMove = L.Util.throttle(this._move, this.options.mouseInterval, this);

        if (this.options.pointerCursor) {
            this._updateCursor = function(cursor) { this._container.style.cursor = cursor; }
        }

        map.on('boxzoomstart', this._disconnectMapEventHandlers, this);
        // have to throttle or we get an immediate click event on boxzoomend
        map.on('boxzoomend', this._throttleConnectEventHandlers, this);
        this._connectMapEventHandlers();
	},

	onRemove: function () {
		var map = this._map;
        map.off('boxzoomstart', this._disconnectMapEventHandlers, this);
        map.off('boxzoomend', this._throttleConnectEventHandlers, this);
        this._disconnectMapEventHandlers();
		this._updateCursor('');
        L.TileLayer.prototype.onRemove.call(this, map);
	},

    createTile: function(coords) {
        this._loadTile(coords);
        return document.createElement('div');  // empty DOM node, required because this overrides L.TileLayer
	},

    setUrl: function(url, noRedraw) {
        this._cache = {};
        return L.TileLayer.prototype.setUrl.call(this, url, noRedraw);
    },

    _connectMapEventHandlers: function(){
        this._map.on('click', this._onClick, this);
        this._map.on('mousemove', this._throttleMove, this);
    },

    _disconnectMapEventHandlers: function(){
        this._map.off('click', this._onClick, this);
		this._map.off('mousemove', this._throttleMove, this);
    },

    _throttleConnectEventHandlers: function() {
        setTimeout(this._connectMapEventHandlers.bind(this), 100);
    },

    _update: function (center, zoom) {
        L.TileLayer.prototype._update.call(this, center, zoom);
    },

    _loadTile: function (coords) {
        var url = this.getTileUrl(coords);
		var key = this._tileCoordsToKey(coords);
		var self = this;
        if (this._cache[key]) { return }
        corslite(url, function(err, response){
            if (err) {
                self.fire('error', {error: err});
                return;
            }
            var data = JSON.parse(response.responseText);
            self._cache[key] = data;
            L.Util.bind(self._handleTileLoad, self)(key, data);
        }, true);
	},

    _handleTileLoad: function(key, data) {
        // extension point
    },

	_onClick: function (e) {
		this.fire('click', this._objectForEvent(e));
	},

	_move: function (e) {
        if (e.latlng == null){ return }

		var on = this._objectForEvent(e);

        if (on._tileCharCode !== this._tileCharCode) {
			if (this._mouseOn) {
				this.fire('mouseout', {
                    latlng: e.latlng,
                    data: this._mouseOn,
                    _tile: this._mouseOnTile,
                    _tileCharCode: this._tileCharCode
                });
				this._updateCursor('');
			}
			if (on.data) {
				this.fire('mouseover', on);
				this._updateCursor('pointer');
			}

			this._mouseOn = on.data;
            this._mouseOnTile = on._tile;
            this._tileCharCode = on._tileCharCode;
		} else if (on.data) {
			this.fire('mousemove', on);
		}
	},

	_objectForEvent: function (e) {
	    if (!e.latlng) return;  // keyboard <ENTER> events also pass through as click events but don't have latlng

        var map = this._map,
		    point = map.project(e.latlng),
		    tileSize = this.options.tileSize,
		    resolution = this.options.resolution,
		    x = Math.floor(point.x / tileSize),
		    y = Math.floor(point.y / tileSize),
		    gridX = Math.floor((point.x - (x * tileSize)) / resolution),
		    gridY = Math.floor((point.y - (y * tileSize)) / resolution),
			max = map.options.crs.scale(map.getZoom()) / tileSize;

        x = (x + max) % max;
        y = (y + max) % max;

        var tileKey = this._tileCoordsToKey({z: map.getZoom(), x: x, y: y});

		var data = this._cache[tileKey];
		if (!data) {
			return {
                latlng: e.latlng,
                data: null,
                _tile: null,
                _tileCharCode: null
            };
		}

        var charCode = data.grid[gridY].charCodeAt(gridX);
		var idx = this._utfDecode(charCode),
		    key = data.keys[idx],
		    result = data.data[key];

		if (!data.data.hasOwnProperty(key)) {
			result = null;
		}

		return {
            latlng: e.latlng,
            data: result,
            id: (result)? result.id: null,
            _tile: tileKey,
            _tileCharCode: tileKey + ':' + charCode
        };
	},

    _dataForCharCode: function (tileKey, charCode) {
        var data = this._cache[tileKey];
        var idx = this._utfDecode(charCode),
		    key = data.keys[idx],
		    result = data.data[key];

		if (!data.data.hasOwnProperty(key)) {
			result = null;
		}
        return result;
    },

	_utfDecode: function (c) {
		if (c >= 93) {
			c--;
		}
		if (c >= 35) {
			c--;
		}
		return c - 32;
	},

    _utfEncode: function (c) {
        //reverse of above, returns charCode for c
        //derived from: https://github.com/mapbox/glower/blob/mb-pages/src/glower.js#L37
        var charCode = c + 32;
        if (charCode >= 34) {
            charCode ++;
        }
        if (charCode >= 92) {
            charCode ++;
        }
        return charCode;
    }
});

L.utfGrid = function (url, options) {
	return new L.UTFGrid(url, options);
};

L.UTFGridCanvas = L.UTFGrid.extend({
	options: {
        idField: 'ID',  // Expects UTFgrid to have a property 'ID' that indicates the feature ID
        buildIndex: true,  // requires above field to be set properly
        fillColor: 'black',
	    shadowBlur: 0,  // Number of pixels for blur effect
        shadowColor: null,  // Color for shadow, if present.  Defaults to fillColor.
        debug: false  // if true, show tile borders and tile keys
    },

    _adjacentTiles: null,

    onAdd: function (map) {
        this._adjacentTiles = [];

        L.UTFGrid.prototype.onAdd.call(this, map);
	},

    createTile: function(coords) {
        this._loadTile(coords);

        var tile = document.createElement('canvas');
        tile.width = tile.height = this.options.tileSize;

        if (this.options.debug) {
            this._drawDefaultTile(tile.getContext('2d'), this._tileCoordsToKey(coords));
        }

        return tile;
	},

    _connectMapEventHandlers: function(){
        L.UTFGrid.prototype._connectMapEventHandlers.call(this);
        this.on('mouseover', this._handleMouseOver, this);
        this.on('mouseout', this._handleMouseOut, this);
    },

    _disconnectMapEventHandlers: function(){
        L.UTFGrid.prototype._disconnectMapEventHandlers.call(this);
        this.off('mouseover', this._handleMouseOver, this);
        this.off('mouseout', this._handleMouseOut, this);
    },

    _handleMouseOver: function (e) {
        if (e._tile == null || e._tileCharCode == null){ return }

        this._clearAdjacentTiles();

        // currently over this tile:
        var curTile = e._tile;
        this._drawTile(curTile, parseInt(e._tileCharCode.split(':')[3]));

        if (e.data && this._idIndex) {
            // draw adjacent tiles
            var id = e.data[this.options.idField];
            var zoomLevel = curTile.split(':')[2];
            if (!(id && this._idIndex[id] && this._idIndex[id][zoomLevel])) { return }

            var idx = this._idIndex[id][zoomLevel];
            for (var tileKey in idx) {
                //TODO: screen out any tiles that are not currently visible?
                if (tileKey !== curTile) {
                    this._drawTile(tileKey, idx[tileKey]);
                    this._adjacentTiles.push(tileKey);
                }
            }
        }
    },

    _handleMouseOut: function (e) {
        this._resetTile(e._tile);
        this._clearAdjacentTiles();
    },

    _clearAdjacentTiles: function() {
        // clear out any adjacent tiles that were drawn
        if (this._adjacentTiles) {
            for (var i = 0; i < this._adjacentTiles.length; i++) {
                this._resetTile(this._adjacentTiles[i]);
            }
            this._adjacentTiles = [];
        }
    },

    _handleTileLoad: function(tileKey, data) {
        // build index: {<id: {zoomLevel: {tileKey: tileCharCode} } }
        if (this.options.buildIndex) {
            var id, props, idx;
            var idField = this.options.idField;
            var zoomLevel = tileKey.split(':')[2];
            for (var i = 0; i < data.keys.length; i++) {
                props = data.data[data.keys[i]];
                if (props) {
                    id = props[idField];
                    if (id) {
                        if (this._idIndex[id] == null) {
                            this._idIndex[id] = {};
                        }
                        idx = this._idIndex[id];
                        if (idx[zoomLevel] == null) {
                            idx[zoomLevel] = {};
                        }
                        idx[zoomLevel][tileKey] = this._utfEncode(i);
                    }
                }
            }
        }
    },

    _drawTile: function(tileKey, charCode) {
        // for a given tile, find all pixels that match character and repaint
        // TODO: request animation frame?

        if (this._tiles[tileKey] == null){ return }

        var canvas = this._tiles[tileKey].el;
        var ctx = canvas.getContext('2d');

        this._resetTile(tileKey);
        var grid = this._cache[tileKey].grid;

        ctx.fillStyle = this.options.fillColor;
        var dim = this.options.tileSize / this.options.resolution;

        // TODO: order of traversal here may be backwards?  Do y then x?  (are data column major or row major?)
        //modified slightly from: https://github.com/mapbox/glower/blob/mb-pages/src/glower.js
        for (var x = 0; x < dim; x++) {
            for (var y = 0; y < dim; y++) {
                if (grid[y].charCodeAt(x) === charCode) {
                    var sweep = 1;
                    while (y < 63 && grid[y + 1].charCodeAt(x) === charCode) {
                        y++;
                        sweep++;
                    }
                    ctx.fillRect(x * 4, (y * 4) - ((sweep - 1) * 4), 4, 4 * sweep);
                }
            }
        }

        if (this.options.shadowBlur) {
            this._addShadow(canvas, ctx);
        }
	
    },

    _resetTile: function(tileKey) {
        // clear the canvas
        if (this._tiles[tileKey] == null){ return }

        var tile = this._tiles[tileKey].el;
        tile.width = this.options.tileSize;  // hard reset of canvas

        if (this.options.debug) {
            this._drawDefaultTile(tile.getContext('2d'), tileKey);
        }
    },

    _drawDefaultTile: function(ctx, tileKey) {
        // if this.options.debug, add tileKey text and borders
        ctx.fillStyle = 'black';
        ctx.fillText(tileKey, 20, 20);
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(255, 0);
        ctx.lineTo(255, 255);
        ctx.lineTo(0, 255);
        ctx.closePath();
        ctx.stroke();
    },

    _addShadow: function(canvas, ctx) {
        ctx.shadowBlur = this.options.shadowBlur;
        ctx.shadowColor = this.options.shadowColor || this.options.fillColor;

        //Blur effect copied from glower - https://github.com/cutting-room-floor/glower/blob/mb-pages/src/glower.js#L108
        ctx.globalAlpha = 0.7;
        ctx.globalCompositeOperation = 'lighter';
        var a = 1;
        ctx.drawImage(canvas, -a, -a);
        ctx.drawImage(canvas, a, a);
        ctx.drawImage(canvas, 0, -a);
        ctx.drawImage(canvas, -a, 0);
        ctx.globalAlpha = 1;
    }
});

L.utfGridCanvas = function (url, options) {
	return new L.UTFGridCanvas(url, options);
};

// iNaturalist UTFGrid Compare
function freplacexyz(url,x,y,z) {
   url = url.replace('{x}',x);
   url = url.replace('{y}',y);
   url = url.replace('{z}',z);
   return url;
};
function fgetutfgrid(url) {
   return fetch(url)
      .then((response) => {
         if (!response.ok) { throw new Error(response.status+': '+response.statusText); };
         return response.json();
      })
//      .then((data) => { return data; })
      .catch((err) => { console.error(err); });
};
L.GridLayer.UTFGridCompare = L.GridLayer.extend({
   createTile: function (coords, done) {

      var tile = document.createElement('canvas');
      var tileSize = this.getTileSize();
      tile.width = tileSize.x;
      tile.height = tileSize.y;
      var cellsPerTile = {x:64,y:64};
      var cellSize = {x:tileSize.x/cellsPerTile.x,y:tileSize.y/cellsPerTile.y};
      var ctx = tile.getContext('2d');

      // default marker setups
      var dmarker = {type:'relative',offset:{x:0,y:0},size:0.75,opacity:0.5};
      var marker = null;
      if (this.options.marker) {
         marker = this.options.marker;
         marker.type = marker.type || dmarker.type;
         marker.size = marker.size || dmarker.size;
         marker.offset = marker.offset || dmarker.offset;
         marker.opacity = marker.opacity || dmarker.opacity;
      }
      else { marker = dmarker };
      var offset = marker.offset;

      // get UTFgrids
      url0 = this.options.urlcompare;
      url1 = this.options.url;
      var prom0 = fgetutfgrid(freplacexyz(url0,coords.x,coords.y,coords.z));
      var prom1 = fgetutfgrid(freplacexyz(url1,coords.x,coords.y,coords.z));
      Promise.all([prom0,prom1]).then(function(utfgrid) {
         //draw markers on the tile canvas
         //note that this code was originally written to assume a 64x64 UTFgrid.
         //although the UTFgrid is still 64x64, the associated "grid tile" is actually only 32x32.
         //theoretically, a 2x2 set of cells from the UTFgrid should correspond to a single cell from the "grid tile"; however, that is not actually the case (see https://forum.inaturalist.org/t/open-test-of-map-tile-improvements/7833/88).
         //so this code attempts to mimic a 32x32 "grid tile" by using the bottom-right cell from each 2x2 set of UTFgrid cells. 
         //for (cx=0;cx<cellsPerTile.x;cx++) {
         for (cx=0;cx<cellsPerTile.x/2;cx++) {
            //for (cy=0;cy<cellsPerTile.y;cy++) {
            for (cy=0;cy<cellsPerTile.y/2;cy++) {
               //var cell = {x:cx,y:cy};
               var cell = {x:cx*2+1,y:cy*2+1};
               //for details about decoding the UTFgrid, see https://github.com/mapbox/utfgrid-spec/blob/master/1.2/utfgrid.md
               var d = [];
               for (u=0;u<utfgrid.length;u++) {
                  var i = utfgrid[u].grid[cell.y].charCodeAt(cell.x);
                  i = i-((i>=93)?34:(i>=35)?33:32);
                  d.push(utfgrid[u].data[utfgrid[u].keys[i]]);
               };
               for (j=0;j<d.length;j++) { d[j] = d[j] ? d[j].cellCount||0 : 0; } // set d = cellCount (set to 0 if undefined)
               var markerColor = 0; // default to black
               ctx.beginPath();
               var circleRadius = cellSize.x*marker.size;
               ctx.arc(cell.x*cellSize.x+offset.x,cell.y*cellSize.y+offset.y,circleRadius,0,2*Math.PI,false);
               if ( d[0]<=0 ) { markerColor = 'rgba(128,128,128,0.00)'; } // no color
               // else if ( d[1]<=0 ) { markerColor = `rgba(0,0,255,${marker.opacity})`; } // blue
               else {
                  var f = d[1]/d[0];
                  f = (f<=0)?1:(f>=1)?0:1-f;
                  markerColor = `hsla(${(f*240)},100%,50%,${marker.opacity})`; // high (1.0) is red, low (0.0) is blue
                  ctx.fillStyle = markerColor;
                  ctx.fill();
               };
               ctx.strokeStyle = markerColor;
               ctx.stroke();
            };
         };
      });  

      // asynchronous call
      setTimeout(function() {
         done(null, tile);
      }, 1000);
      return tile;
   }
});
L.gridLayer.utfGridCompare = function (options) {
   return new L.GridLayer.UTFGridCompare(options);
};


</script>
</head>
<body>

<script>
//get parameters from the url
let winurlstr = window.location.href;
let winurlsearchstr = window.location.search;
let winurlexsearchstr = winurlstr.replace(winurlsearchstr,'');
let winurlparams = new URLSearchParams(winurlsearchstr.substring(1));
var taxon_id = winurlparams.get('taxon_id');
taxon_id = (taxon_id===null?null:taxon_id.split(',')[0]);
var place_id = winurlparams.get('place_id');
place_id = (place_id===null?null:place_id.split(',')[0]);
var centerlat = winurlparams.get('centerlat');
var centerlng = winurlparams.get('centerlng');
var defaultzoom = winurlparams.get('defaultzoom');
var showtaxonplace = winurlparams.get('showtaxonplace') || 'false';
var showtaxonrange = winurlparams.get('showtaxonrange') || 'false';
var showplace = winurlparams.get('showplace') || 'false';
var view = winurlparams.get('view') || 'default';
var compexclparam = winurlparams.get('compare_exclude_param');

winurlparams.delete('centerlat');
winurlparams.delete('centerlng');
winurlparams.delete('defaultzoom');
winurlparams.delete('showtaxonplace');
winurlparams.delete('showtaxonrange');
winurlparams.delete('showplace');
winurlparams.delete('view');
winurlparams.delete('compare_exclude_param');

let compareurlparams = new URLSearchParams(winurlparams);
if (compexclparam) { for (p of compexclparam.split(',')) { compareurlparams.delete(p); }; };

function fdate(str) {
   str = str.replace(/t/i,' '); //replaces T (case insensitive) with a space
   str = str.replace(/([+-]\d{2}\:?\d{2})/,' ($1)'); //puts parenthesis around time zone offset
   str = str.replace(/z/i,' (+00:00)'); //replaces Z (case insensitve) with UTC
   str = str.replace('+00:00','Â±00:00');
   return str;
};
function fround(num,places) {
   var n = num*1;
   return n.toFixed(places); 
};
function furl(url,txt=url) { return '<a href="'+url+'">'+txt+'</a>'; };
function faddelem(etype,eparent=null,eclass=null,eid=null,ehtml=null,etext=null) {
   var eobj = document.createElement(etype);
   if (eclass!==null) { eobj.classList = eclass };
   if (eid!==null) { eobj.id = eid };
   if (ehtml!==null) { eobj.innerHTML = ehtml };
   if (etext!==null) { eobj.innerText = etext };
   if (eparent!==null) { eparent.appendChild(eobj); };
   return eobj;
};
function ffetch(url) {
   return fetch(url)
      .then((response) => {
         if (!response.ok) { throw new Error(response.status+': '+response.statusText); };
         return response.json();
      })
      .then((data) => { return data; })
      .catch((err) => { console.error(err); });
};

let inat_urlbase = 'https://api.inaturalist.org/v1/';
if (winurlparams=="") {
   var div = faddelem('div',document.body,null,'info');
   faddelem('h1',div,null,null,'Map of iNaturalist Observations');
   faddelem('p',div,null,null,'This page displays a map of iNaturalist observations. Clicking on any observation marker opens a pop-up window which provides basic details of the observation');
   faddelem('p',div,null,null,'This page requires that you input at least one filter parameter in the URL. For example, if the URL of this page is '+winurlexsearchstr +', and you want to see research grade ocotillo observations, then you would navigate to '+furl(winurlexsearchstr+'?taxon_id=49325&quality_grade=research')+' in your web browser. This page will accept most parameters documented for the '+ furl(inat_urlbase+'docs/#!/Observations/get_observations','iNaturalist API Get Observations Endpoint')+ '.');
   faddelem('p',div,null,null,'If place_id is included as a parameter, then the place polygon will be available as an optional layer in the map. If taxon_id is included as a parameter, then taxon places and taxon range will be available as optional layers in this map (if they have been defined in iNaturalist).');
   faddelem('p',div,null,null,'If a special "view" parameter is set to "=elevation", then the map will display with the USGS topo basemap (with contours in feet) by default, and the info pop-ups will include elevation (sourced from the '+furl('https://epqs.nationalmap.gov/','USGS elevation point query service')+'). USGS does not provide elevations outside of the United States. In cases where the USGS returns no data, the page will fall back to the '+furl('https://open-elevation.com/','Open-Elevation API')+'. As an example, if you want to see mountain goats in the United States, then you would navigate to '+furl(winurlexsearchstr+'?view=elevation&taxon_id=42414&place_id=1')+' in your web browser.');
   faddelem('p',div,null,null,'If a special "view" parameter is set to "=ecolandunit", then the map will display with a USGS Ecological Land Unit overlay on a dark basemap by default, and the info pop-ups will include USGS ELU information (sourced from '+furl('https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems','USGS Global Ecosystems')+'). This should work on any point of land worldwide. As an example, if you want to see maples around the world, then you would navigate to '+furl(winurlexsearchstr+'?view=ecolandunit&taxon_id=47727&defaultzoom=2')+' in your web browser.');
   faddelem('p',div,null,null,'If a special "view" parameter is set to "=heatmap", then the map will show a heatmap view of observations on a muted-color basemap. By default, clicking the heatmap will not open a info pop-up. As an example, to get an idea of where user kueda has made observations, you would navigate to '+furl(winurlexsearchstr+'?view=heatmap&user_id=kueda')+' in your web browser.');
   faddelem('p',div,null,null,'If a special "view" parameter is set to "=subsetratio", then the map will compare a gridded view of one set of observations (the subset, defined in the URL) to another set (the superset, defined by a required special "compare_exclude_param" parameter, which removes one or more parameters from the subset parameter list). The color of the markers will vary based on the ratio of subset to superset for each cell (red=1.0 and blue=0.0), and they will appear on top of a gray basemap. As an example, to compare research grade plant observations to verifiable plant observations, you would navigate to '+furl(winurlexsearchstr+'?view=subsetratio&verifiable=true&quality_grade=research&taxon_id=47126&compare_exclude_param=quality_grade')+' in your web browser. Note that if you use exclusion filter parameters (ex. not_user_id) in your subset and remove them from the superset, then you may get unexpected results (because the subset would no longer be a true subset).');    faddelem('p',div,null,null,'There are 2 final sets of special parameters: centerlat, centerlng, and defaultzoom can be used to set the default map center and zoom level when the map is first opened; and showtaxonplace, showtaxonrange, showplace can be set to true to display specific layers by default.');
}
else {
   var mapdiv = faddelem('div',document.body,null,'mapid');

   // iNat Observation Layer, using grid markers at lower zooms and points at higher zooms
//   let inat_circles = {url:inat_urlbase+'colored_heatmap/{z}/{x}/{y}.png',description:'iNaturalist Observations (Density Circles)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_colored_heatmap_zoom_x_y_png">iNaturalist observation data</a>'};
   let inat_heat = {url:inat_urlbase+'heatmap/{z}/{x}/{y}.png',description:'iNaturalist Observations (Heatmap)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_heatmap_zoom_x_y_png">iNaturalist observation data</a>'};
//   let gbif_density_point_py = {url:'https://api.gbif.org/v2/map/occurrence/density/{z}/{x}/{y}@1x.png?srs=EPSG:3857&style=purpleYellow.point&publishingOrg=28eb1a3f-1c15-4a95-931a-4af90ecb574d',description:'iNaturalist Observations in GBIF',attribution:'<a href="https://www.gbif.org/developer/maps">GBIF occurrence data</a>'};
//   var l_inat_circles = L.tileLayer(inat_circles.url+'?'+winurlparams,{minZoom:2, maxZoom:20, attribution:inat_circles.attribution});
   var l_inat_heat = L.tileLayer(inat_heat.url+'?'+winurlparams,{minZoom:0, maxZoom:20, attribution:inat_heat.attribution});
//   var l_gbif = L.tileLayer(gbif_density_point_py.url,{minZoom:2, maxZoom:20, attribution:gbif_density_point_py.attribution});
   let inat_points = {url:inat_urlbase+'points/{z}/{x}/{y}.png',description:'iNaturalist Observations (Points)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_points_zoom_x_y_png">iNaturalist observation data</a>'};
   let inat_grid = {url:inat_urlbase+'grid/{z}/{x}/{y}.png',description:'iNaturalist Observations (Grid)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_grid_zoom_x_y_png">iNaturalist observation data</a>'};
   var l_inat_points = L.tileLayer(inat_points.url+'?'+winurlparams,{minZoom:0,maxZoom:20, attribution:inat_points.attribution});
   var l_inat_grid = L.tileLayer(inat_grid.url+'?'+winurlparams,{minZoom:0,maxZoom:20,attribution:inat_grid.attribution});
   var l_inat_obs_points = L.tileLayer(inat_points.url+'?'+winurlparams,{minZoom:10,maxZoom:20, attribution:inat_points.attribution});
   var l_inat_obs_grid = L.tileLayer(inat_grid.url+'?'+winurlparams,{minZoom:2,maxZoom:9,attribution:inat_grid.attribution});
   var g_inat_obs = L.layerGroup([l_inat_obs_grid,l_inat_obs_points]);

   // iNat Observation Layer mods
   var l_inat_heat_mod_transparent = L.tileLayer.styleFilter(inat_heat.url+'?'+winurlparams,{minZoom:0, maxZoom:20, attribution:inat_heat.attribution, filter:'opacity(50%)'});

   // iNat UTFGrid Selection
   // (hover to see selected area, and click to view selected observation)
   async function fpopup(obs,count) {
      var s = (obs.photos.length==0) ? '[No Photo]' : '<img src="'+obs.photos[0].url+'" />';
      s += (obs.photos.length>1) ? ' ['+obs.photos.length+']' : '';
      s += '<br />observation #: <a target="_blank" href="'+obs.uri+'">'+obs.id+'</a> (grade: '+obs.quality_grade+')';
      s += '<br />taxon: ' + ((obs.taxon==null) ? '[Unknown]' : obs.taxon.preferred_common_name ? (obs.taxon.preferred_common_name+' ('+obs.taxon.name+')') : obs.taxon.name );
      s += '<br />observer: '+obs.user.login;
//      s += '<br />location: '+obs.place_guess;
      s += '<br />coordinates: '+fround(obs.geojson.coordinates[1],6)+', '+fround(obs.geojson.coordinates[0],6);
      s += (obs.positional_accuracy==null) ? '' : ' ('+fround(obs.positional_accuracy,1)+'m)';
      if (view==='elevation') {
         var elevationurl = 'https://epqs.nationalmap.gov/v1/json?y='+obs.geojson.coordinates[1]+'&x='+obs.geojson.coordinates[0]+'&output=json&units=Feet';
         var elevation = await ffetch(elevationurl)
            .then((data) => {
               return data;
            });
         if ((elevation?elevation.value:-1000000)>-1000000) { s += '<br />elevation: '+ (fround(elevation.value,1)+'ft, '+ fround(elevation.value*0.3048,1) + 'm'); }
         else {
            var elevationurl_fallback = 'https://api.open-elevation.com/api/v1/lookup?locations='+obs.geojson.coordinates[1]+','+obs.geojson.coordinates[0];
            var elevation_fallback = await ffetch(elevationurl_fallback)
               .then((data) => {
                  return data?.results[0];
               });
            s += '<br />elevation: '+ (elevation_fallback?(elevation_fallback.elevation+'m'):'[Unknown]');
         };
      };
      s += '<br />observed: '+((obs.time_observed_at==null) ? ((obs.observed_on==null) ? '[Unknown]': obs.observed_on) : fdate(obs.time_observed_at));
      s += '<br />created: '+((obs.created_at==null) ? obs.created_at_details.date : fdate(obs.created_at));
      s += '<br />last updated: '+fdate(obs.updated_at);
//      if (obs.description==null) {}
//      else if (obs.description.length < 200) {s += '<br />'+obs.description }
//      else {s += '<br />'+(obs.description.substring(0,191)+'... (more)')};
      if (view==='ecolandunit') {
         function latlngtoxy(latlng) { return L.CRS.EPSG3857.project(latlng); };
         let mapExtent = mymap.getBounds();
         let pointXY = latlngtoxy(L.latLng(obs.geojson.coordinates[1],obs.geojson.coordinates[0]));
         var ecoluurl = `https://rmgsc.cr.usgs.gov/arcgis/rest/services/globalelus/MapServer/identify?geometry={"x":${pointXY.x},"y":${pointXY.y}}&geometryType=esriGeometryPoint&sr=102100&layers=all:4&tolerance=3&mapExtent=${latlngtoxy(mapExtent.getNorthWest()).x},${latlngtoxy(mapExtent.getNorthWest()).y},${latlngtoxy(mapExtent.getSouthEast()).x},${latlngtoxy(mapExtent.getSouthEast()).y}&imageDisplay=1,1,96&returnGeometry=false&returnZ=false&returnM=false&returnUnformattedValues=false&f=pjson`;
         var ecoludetails = await ffetch(ecoluurl)
            .then((data) => {
               return data.results[0].attributes;
            });
         s += '<hr /><details>'
         s += '<summary>Ecological Land Unit: ' + (ecoludetails ? (ecoludetails['Raster.ELU'] ?? 'N/A') : 'N/A') + '</summary>';
         s += '- Bioclimate: ' + (ecoludetails ? (ecoludetails['Raster.ELU_Bio_De'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Cover: ' + (ecoludetails ? (ecoludetails['Raster.ELU_GLC_De'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Form: ' + (ecoludetails ? (ecoludetails['Raster.ELU_LF_Des'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Lithology: ' + (ecoludetails ? (ecoludetails['Raster.ELU_Lit_De'] ?? 'N/A') : 'N/A');
         s += '</details>';
         s += '<hr /><details>';
         s += '<summary>Ecological Facet: ' + (ecoludetails ? (ecoludetails['Raster.EF'] ?? 'N/A') : 'N/A') + '</summary>';
         s += '- Bioclimate: ' + (ecoludetails ? (ecoludetails['Raster.EF_Bio_Des'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Cover: ' + (ecoludetails ? (ecoludetails['Raster.EF_GLC_Des'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Form: ' + (ecoludetails ? (ecoludetails['Raster.EF_LF_Desc'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Lithology: ' + (ecoludetails ? (ecoludetails['Raster.EF_Lit_Des'] ?? 'N/A') : 'N/A');
         s += '</details>';

         var ecosysdetails;
         let contSets = ['US','SA','AF'];
         for (let cont of contSets) {
            var ecosysurl = `https://rmgsc.cr.usgs.gov/arcgis/rest/services/cont${cont}/MapServer/identify?geometry={"x":${pointXY.x},"y":${pointXY.y}}&geometryType=esriGeometryPoint&sr=102100&layers=all:0,1,2,3,4&tolerance=3&mapExtent=${latlngtoxy(mapExtent.getNorthWest()).x},${latlngtoxy(mapExtent.getNorthWest()).y},${latlngtoxy(mapExtent.getSouthEast()).x},${latlngtoxy(mapExtent.getSouthEast()).y}&imageDisplay=1,1,96&returnGeometry=false&returnZ=false&returnM=false&returnUnformattedValues=false&f=pjson`;
            ecosysdetails = await ffetch(ecosysurl)
               .then((data) => {
                  return ((data.results?.length||0)===0) ? null : data.results;
               });
            if (ecosysdetails) { break; };
         };
         
         if (ecosysdetails) {
         s += '<hr /><details>';
            s += '<summary>Ecosystem: ' + (ecosysdetails[0]?.attributes ? (ecosysdetails[0]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A') + '</summary>';
            s += '- Bioclimate: ' + (ecosysdetails[1].attributes ? (ecosysdetails[1].attributes['Raster.code_desc'] ?? 'N/A') : 'N/A');
            s += '<br /> - Land Form: ' + (ecosysdetails[2]?.attributes ? (ecosysdetails[2]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A');
            s += '<br /> - Land Lithology: ' + (ecosysdetails[3]?.attributes ? (ecosysdetails[3]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A');
            if (ecosysdetails.length>4) {s += '<br /> - Topographic Position: ' + (ecosysdetails[4]?.attributes ? (ecosysdetails[4]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A'); };
            s += '</details>';
         };
      };
      if (count>1) {
         s += '<hr />'
         s += `This marker also denotes ${count-1} older observation${(count>2)?'s':''}.`
      };
      L.popup().setLatLng([obs.geojson.coordinates[1],obs.geojson.coordinates[0]])
         .setContent(s).openOn(mymap);
   };

   var u_inat_options = {
      resolution: 4,
      pointerCursor: true,
      mouseInterval: 66,  // Delay for mousemove events
      minZoom:0,
      maxZoom:20, 
   };

   var u_inat_points = L.utfGrid(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, { ...u_inat_options, minZoom:10 });
   u_inat_points.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });

   var u_inat_points_all = L.utfGrid(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, u_inat_options);
   u_inat_points_all.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });

   var u_inat_grid = L.utfGrid(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, { ...u_inat_options, minZoom:2, maxZoom:9 });
   u_inat_grid.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });

   var u_inat_grid_all = L.utfGrid(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, u_inat_options);
   u_inat_grid_all.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });

   var u_inat_grid_superset = L.utfGrid(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+compareurlparams, u_inat_options);
   u_inat_grid_superset.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });

   var v_inat_options = {
      idField: 'id',  // Expects UTFgrid to have a property 'ID' that indicates the feature ID
      buildIndex: true,  // requires above field to be set properly
      fillColor: 'black',
      shadowBlur: 0,  // Number of pixels for blur effect
      shadowColor: null,  // Color for shadow, if present.  Defaults to fillColor.
      debug: false,  // if true, show tile borders and tile keys
      minZoom:0,
      maxZoom:20, 
   };

   var v_inat_points = L.utfGridCanvas(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, { ...v_inat_options, minZoom:10, });
   var v_inat_points_all = L.utfGridCanvas(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, v_inat_options);
   var v_inat_grid = L.utfGridCanvas(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, { ...v_inat_options, minZoom:2, maxZoom:9 });
   var v_inat_grid_all = L.utfGridCanvas(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, v_inat_options);
   var v_inat_grid_superset = L.utfGridCanvas(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+compareurlparams, v_inat_options);

   var g_utfgdm_sel = L.layerGroup([u_inat_grid,u_inat_points,v_inat_grid,v_inat_points]);
   var g_utfgdm_sel_points = L.layerGroup([u_inat_points_all,v_inat_points_all]);
   var g_utfgdm_sel_grid = L.layerGroup([u_inat_grid_all,v_inat_grid_all]);
   var g_utfgdm_sel_superset = L.layerGroup([u_inat_grid_superset,v_inat_grid_superset]);

   // iNat UTFGrid Comparison Layer
   // note that iNat provides 4 UTFGrid endpoints. the grid and heatmap endpoints are interchangeable and the ones to use for this application.
   let utfgridapi = {url:'https://api.inaturalist.org/v1/grid/{z}/{x}/{y}.grid.json',attr:'<a href="https://api.inaturalist.org/v1/docs/#!/UTFGrid/get_grid_zoom_x_y_grid_json">iNaturalist</a>'};
   var l_utfgrid_compare = L.gridLayer.utfGridCompare({url:utfgridapi.url+'?'+winurlparams,attribution:utfgridapi.attr,marker:{size:0.75,opacity:0.5},urlcompare:utfgridapi.url+'?'+compareurlparams})

   // Other iNaturalist Layers
   var l_inat_place = L.tileLayer(inat_urlbase+'places/'+place_id+'/{z}/{x}/{y}.png',{minZoom:2, maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_places_place_id_zoom_x_y_png">iNaturalist place polygon</a>'});

   // iNaturalist Taxon Places Checklist and Range Layers
   var l_inat_taxonplace = L.tileLayer(inat_urlbase+'taxon_places/'+taxon_id+'/{z}/{x}/{y}.png',{minZoom:2, maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_taxon_places_taxon_id_zoom_x_y_png">iNaturalist taxon place checklist data</a>'});
   var l_inat_taxonrange = L.tileLayer(inat_urlbase+'taxon_ranges/'+taxon_id+'/{z}/{x}/{y}.png',{minZoom:2, maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_taxon_ranges_taxon_id_zoom_x_y_png">iNaturalist taxon range data</a>'});

   // Stamen layers
   // these are deprecated as Stamen tiles are now maintained by Stadia
   var s_stamen_copyright = 'Map tiles by <a href="https://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://www.openstreetmap.org/copyright">ODbL</a>.'; // used for all sets except Watercolor
   var s_stamen_urlbase = 'https://stamen-tiles-{s}.a.ssl.fastly.net/';
   //var l_stamen_watercolor = L.tileLayer(s_stamen_urlbase+'watercolor/{z}/{x}/{y}.jpg',{minZoom:0, maxZoom:20, attribution:'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'});
   //var l_stamen_terrain = L.tileLayer(s_stamen_urlbase+'terrain/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_terrainbg = L.tileLayer(s_stamen_urlbase+'terrain-background/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_terrainlines = L.tileLayer(s_stamen_urlbase+'terrain-lines/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_terrainlabels = L.tileLayer(s_stamen_urlbase+'terrain-labels/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_toner = L.tileLayer(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerlite = L.tileLayer(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerbg = L.tileLayer(s_stamen_urlbase+'toner-background/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerhybrid = L.tileLayer(s_stamen_urlbase+'toner-hybrid/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerlines = L.tileLayer(s_stamen_urlbase+'toner-lines/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerlabels = L.tileLayer(s_stamen_urlbase+'toner-labels/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   // Stamen layer mods
   //var l_stamen_toner_mod_dark25 = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(25%)'});
   //var l_stamen_toner_mod_dark70 = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(70%)'});
   //var l_stamen_toner_mod_green_on_black = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(40%) sepia(40%) hue-rotate(60deg) saturate(400%) contrast(200%)'});
   //var l_stamen_toner_mod_black_on_blue = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'invert(100%) brightness(60%) sepia(100%) hue-rotate(180deg) saturate(150%)'});
   //var l_stamen_tonerlite_mod_dark50 = L.tileLayer.styleFilter(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(50%) contrast(125%)'});
   //var l_stamen_tonerlite_mod_dark_with_purple = L.tileLayer.styleFilter(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'invert(100%) brightness(70%) sepia(100%) hue-rotate(205deg) saturate(160%)'});
   //var l_stamen_tonerlite_mod_olive = L.tileLayer.styleFilter(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(50%) sepia(100%) hue-rotate(15deg) saturate(160%)'});
   //var l_stamen_watercolor_mod_gray = L.tileLayer.styleFilter(s_stamen_urlbase+'watercolor/{z}/{x}/{y}.jpg',{minZoom:0, maxZoom:20, attribution:'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.', filter:'grayscale(85%)'});

   // Stamen Watercolor (now housed at Smithsonian)
   let s_watercolor = {url:'https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/{z}/{x}/{y}.jpg', attribution:'Map <a href="https://watercolormaps.collection.cooperhewitt.org">tiles</a> by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'};
   var l_stamen_watercolor = L.tileLayer(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution});
   var l_stamen_watercolor_mod_muted = L.tileLayer.styleFilter(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution, filter:'grayscale(85%)'});
   var l_stamen_watercolor_mod_gray = L.tileLayer.styleFilter(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution, filter:'grayscale(100%)'});
   var l_stamen_watercolor_mod_darkgray = L.tileLayer.styleFilter(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution, filter:'grayscale(100%) brightness(50%)'});

   // OpenStreetMaps & OpenTopoMap
   let s_osm_std = {url:'https://tile.openstreetmap.org/{z}/{x}/{y}.png', attribution:'&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles from <a href="https://osm.org/">OpenStreetMap</a>'};
   var l_osm_std = L.tileLayer(s_osm_std.url, {minZoom:0, maxNativeZoom:19, maxZoom:20, attribution:s_osm_std.attribution});
   var l_osm_de = L.tileLayer('https://tile.openstreetmap.de/{z}/{x}/{y}.png', {minZoom:0, maxZoom:20, attribution:'&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles <a href="https://openstreetmap.de/">OpenStreetMap Deutschland</a>'});
   var l_osm_fr = L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {minZoom:0, maxZoom:20, attribution:'donn&eacute;es &copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - rendu <a href="https://openstreetmap.fr">OSM France</a>'});
   var l_osm_hot = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {minZoom:0, maxNativeZoom:19, maxZoom:20, attribution:'donn&eacute;es &copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - Tiles courtesy of <a href="https://hot.openstreetmap.org/">Humanitarian OpenStreetMap Team</a>'});
   let s_otm = {url:'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', attribution:'Kartendaten: &copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap</a>-Mitwirkende, SRTM | Kartendarstellung: &copy; <a href="http://opentopomap.org/">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'};
   var l_otm = L.tileLayer(s_otm.url,{minZoom:0, maxNativeZoom:17, maxZoom:20, attribution:s_otm.attribution});
   // mods
   var l_otm_mod_muted = L.tileLayer.styleFilter(s_otm.url,{minZoom:0, maxNativeZoom:17, maxZoom:20, attribution:s_otm.attribution, filter:'grayscale(60%)'});
   var l_osm_std_mod_lightgray = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%)'});
   var l_osm_std_mod_medgray = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) brightness(50%) contrast(150%)'});
   var l_osm_std_mod_medgray2 = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) brightness(50%) contrast(150%) invert(100%) contrast(125%)'});
   var l_osm_std_mod_darkgray = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) invert(100%)'});
   var l_osm_std_mod_darkest = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) invert(100%) brightness(80%) contrast(125%)'});

   // EOX -- http://maps.eox.at/
   // capabilities (including attribution) -- https://tiles.maps.eox.at/wmts/1.0.0/WMTSCapabilities.xml
   function f_eox_url(tileset,format) { return `https://tiles.maps.eox.at/wmts/1.0.0/${tileset}/default/g/{z}/{y}/{x}.${format}`; }; 
   // basemaps
   var l_eox_osm = L.tileLayer(f_eox_url('osm_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">OpenStreetMap</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_blackmarble = L.tileLayer(f_eox_url('blackmarble_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Black Marble</a> { &copy; <a href="http://nasa.gov">NASA</a> }'});
   var l_eox_bluemarble = L.tileLayer(f_eox_url('bluemarble_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Blue Marble</a> { &copy; <a href="http://nasa.gov">NASA</a> }'});
   var l_eox_terrain = L.tileLayer(f_eox_url('terrain_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Terrain</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors and <a href="https://maps.eox.at/#data">others</a>, Rendering &copy; <a href="https://eox.at">EOX</a> }'});
   var l_eox_terrain_light = L.tileLayer(f_eox_url('terrain-light_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Terrain Light</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors and <a href="https://maps.eox.at/#data">others</a>, Rendering &copy; <a href="https://eox.at">EOX</a> }'});
   var l_eox_sentinel2_2020 = L.tileLayer(f_eox_url('s2cloudless-2020_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2020) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2019 = L.tileLayer(f_eox_url('s2cloudless-2019_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2019) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2018 = L.tileLayer(f_eox_url('s2cloudless-2018_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2019) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   // overlays
   var l_eox_hydrography = L.tileLayer(f_eox_url('hydrography_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Hydrography overlay</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_coastline = L.tileLayer(f_eox_url('coastline_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Coastline overlay</a> { Rendering &copy; <a href="https://eox.at">EOX</a> }'}); 
   var l_eox_streets = L.tileLayer(f_eox_url('streets_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Streets overlay</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_overlay = L.tileLayer(f_eox_url('overlay_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Overlay</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_overlay_bright = L.tileLayer(f_eox_url('overlay_bright_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Overlay bright</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});

   // USGS maps (US primarily)
   var s_usgs_urlbase = 'https://basemap.nationalmap.gov/arcgis/rest/services/'
   //var l_usgs_topo = L.tileLayer(s_usgs_urlbase+'USGSTopo/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, attribution:'<a href="'+s_usgs_urlbase+'USGSTopo/MapServer">USGS The National Map</a>: National Boundaries Dataset, 3DEP Elevation Program, Geographic Names Information System, National Hydrography Dataset, National Land Cover Database, National Structures Dataset, and National Transportation Dataset; USGS Global Ecosystems; U.S. Census Bureau TIGER/Line data; USFS Road Data; Natural Earth Data; U.S. Department of State Humanitarian Information Unit; and NOAA National Centers for Environmental Information, U.S. Coastal Relief Model'});
   var l_usgs_topo = L.tileLayer(s_usgs_urlbase+'USGSTopo/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, attribution:'<a href="'+s_usgs_urlbase+'USGSTopo/MapServer">USGS The National Map</a>'});
   // var l_stamen_terrain_fallback = L.tileLayer(s_stamen_urlbase+'terrain/{z}/{x}/{y}.jpg',{minZoom:9, maxNativeZoom:16, attribution:s_stamen_copyright});
   var l_eox_terrain_light_fallback = L.tileLayer(f_eox_url('terrain-light_3857','jpg'),{minZoom:9, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Terrain Light</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors and <a href="https://maps.eox.at/#data">others</a>, Rendering &copy; <a href="https://eox.at">EOX</a> }'});
   var g_usgs_topo = L.layerGroup([l_eox_terrain_light_fallback, l_usgs_topo]);
   var l_usgs_img = L.tileLayer(s_usgs_urlbase+'USGSImageryOnly/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSImageryOnly/MapServer">USGS The National Map</a>: Orthoimagery'});
   var l_usgs_imgtopo = L.tileLayer(s_usgs_urlbase+'USGSImageryTopo/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSImageryTopo/MapServer">USGS The National Map</a>: Orthoimagery and US Topo'});
   //var l_usgs_relief = L.tileLayer(s_usgs_urlbase+'USGSShadedReliefOnly/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSShadedReliefOnly/MapServer">USGS The National Map</a>: 3D Elevation Program'});
   var l_usgs_hydro = L.tileLayer(s_usgs_urlbase+'USGSHydroCached/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSHydroCached/MapServer">USGS The National Map</a>: National Hydrography Dataset'});

   // USGS Ecological Land Units (Worldwide coverage)
   // (Note: The WMS Server doesn't respond very well when requesting many tiled images. So we'll request images from the /export route instead using a custom tileLayer extension.)
   //var l_usgs_ecolandunit = L.tileLayer.wms('https://rmgsc.cr.usgs.gov/arcgis/services/globalelus/MapServer/WMSServer?',{minZoom:0, maxZoom:20, attribution:'<a href="https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems">USGS Global Ecosystems</a>', format:'image/png32', transparent:true, layers:'4'});
   var l_usgs_ecolandunit = L.tileLayer.usgs('https://rmgsc.cr.usgs.gov/ArcGIS/rest/services/globalelus/MapServer/export?format=png32&dpi=120&transparent=true&layers=show:0',{minZoom:0, maxZoom:20, attribution:'<a href="https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems">USGS Global Ecosystems</a>', filter:'opacity(100%)'});

   // USGS Elevation (US, Mexico, Canada)
   // (Note: The WMS responds ok. So we don't need to use the /exportImage route to get tiled images.)
   // var s_usgs_3dep_urlbase = 'https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/exportImage';
   var s_usgs_3dep_urlbase = 'https://elevation.nationalmap.gov/arcgis/services/3DEPElevation/ImageServer/WMSServer?';
   var s_usgs_3dep_attribution = '<a href="https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer">USGS 3D Elevation Program</a>';
   var l_usgs_3dep_hillshade = L.tileLayer.wms(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, format:'image/png32', transparent:false, layers:'Hillshade Gray'}); //possible values: 'Hillshade Gray', 'Hillshade Multidirectional' , 'Hillshade Elevation Tinted', 'GreyHillshade_elevationFill'
   var l_usgs_3dep_aspect = L.tileLayer.wms(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, format:'image/png32', transparent:false, layers:'Aspect Map'}); //possible values: 'Aspect Map', 'Aspect Degrees'
   var l_usgs_3dep_slope = L.tileLayer.wms(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, format:'image/png32', transparent:false, layers:'Slope Map'}); //possible values: 'Slope Map', 'Slope Degrees'

   // USGS other overlays (US only)
   // (Note: The WMS Server doesn't respond very well when requesting many tiled images. So we'll request images from the /export route instead using a custom tileLayer extension.)
   var s_usgs_overlay_attribution = '<a href="https://carto.nationalmap.gov/">USGS the National Map</a>'
   //var l_usgs_3dep_contours = L.tileLayer.wms('https://carto.nationalmap.gov/arcgis/services/contours/MapServer/WMSServer?',{minZoom:8, maxZoom:20, attribution:s_usgs_overlay_attribution, layers:'0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35', format:'image/png32', transparent:true});
   //var l_usgs_3dep_transport = L.tileLayer.wms('https://carto.nationalmap.gov/arcgis/services/transportation/MapServer/WMSServer?',{minZoom:4, maxZoom:20, attribution:s_usgs_overlay_attribution, layers:'0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38', format:'image/png32', transparent:true});
   var l_usgs_3dep_contours = L.tileLayer.usgs('https://carto.nationalmap.gov/arcgis/rest/services/contours/MapServer/export?format=png32&dpi=120&transparent=true&layers=show:1,2,3,4,5,6,7,8,10,11,12,13,15,16,17,18,21,22,25,26',{minZoom:8, maxZoom:20, attribution:s_usgs_overlay_attribution, filter:'opacity(100%)'});
   // var l_usgs_3dep_transport = L.tileLayer.usgs('https://carto.nationalmap.gov/arcgis/rest/services/transportation/MapServer/export?format=png32&dpi=120&transparent=true&layers=show:0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38',{minZoom:4, maxZoom:20, attribution:s_usgs_overlay_attribution, filter:'opacity(100%)'});

   var l_graticule = L.tileLayer.wms('https://gis.ngdc.noaa.gov/arcgis/services/web_mercator/graticule/MapServer/WMSServer?',{minZoom:0, maxZoom:20, attribution:s_usgs_overlay_attribution, layers:'0,1,2,3,4,5,6', format:'image/png32', transparent:true});

   //debug layer
   var l_debug = L.gridLayer.debugCoords();

   var defaultlayers = (view==='elevation') ? [g_usgs_topo]
      : (view==='ecolandunit') ? [l_eox_terrain,l_usgs_ecolandunit,l_eox_overlay]
      : (view==='heatmap') ? [l_stamen_watercolor_mod_muted,l_eox_overlay]
      : (view==='subsetratio') ? [l_osm_std_mod_medgray2]
      : [l_osm_std];
   if (taxon_id!==null) {
      if (showtaxonplace==='true') {defaultlayers.push(l_inat_taxonplace)};
      if (showtaxonrange==='true') {defaultlayers.push(l_inat_taxonrange)};
   };
   if (place_id!==null) { 
      if (showplace==='true') {defaultlayers.push(l_inat_place)};
   };
   if (view==='heatmap') {
      defaultlayers.push(l_inat_heat);
   }
   else if (view==='subsetratio' && compexclparam) {
      defaultlayers.push(l_utfgrid_compare);
      defaultlayers.push(g_utfgdm_sel_grid);
   } 
   else {
      defaultlayers.push(g_inat_obs);
      defaultlayers.push(g_utfgdm_sel);
   };

   // define available basemaps (can view only one at a time)
   var basemaps = {
      "Stamen Watercolor": l_stamen_watercolor,
      "Stamen Watercolor Mod (Muted)": l_stamen_watercolor_mod_muted,
      "Stamen Watercolor Mod (Gray)": l_stamen_watercolor_mod_gray,
      "Stamen Watercolor Mod (Dark Gray)": l_stamen_watercolor_mod_darkgray,
      //"Stamen Terrain": l_stamen_terrain,
      //"Stamen Terrain Background": l_stamen_terrainbg,
      //"Stamen Toner": l_stamen_toner,
      //"Stamen Toner Background": l_stamen_tonerbg,
      //"Stamen Toner Lite": l_stamen_tonerlite,
      //"Stamen Toner Mod (Med Dark)": l_stamen_toner_mod_dark70,
      //"Stamen Toner Mod (Dark)": l_stamen_toner_mod_dark25,
      //"Stamen Toner Mod (Green on Black)": l_stamen_toner_mod_green_on_black,
      //"Stamen Toner Mod (Black on Blue)": l_stamen_toner_mod_black_on_blue,
      //"Stamen Toner Lite Mod (Med Dark)": l_stamen_tonerlite_mod_dark50,
      //"Stamen Toner Lite Mod (Dark with Purple)": l_stamen_tonerlite_mod_dark_with_purple,
      //"Stamen Toner Lite Mod (Olive)": l_stamen_tonerlite_mod_olive,
      "OpenTopoMap": l_otm,
      "OpenTopoMap Mod (Muted)": l_otm_mod_muted,
      "OpenStreetMap Standard": l_osm_std,
      "OpenStreetMap Std Mod (Light Gray)": l_osm_std_mod_lightgray,
      "OpenStreetMap Std Mod (Gray 1)": l_osm_std_mod_medgray,
      "OpenStreetMap Std Mod (Gray 2)": l_osm_std_mod_medgray2,
      "OpenStreetMap Std Mod (Dark Gray)": l_osm_std_mod_darkgray,
      "OpenStreetMap Std Mod (Near Black)": l_osm_std_mod_darkest,
      "OpenStreetMap Deutschland": l_osm_de,
      "OpenStreetMap France": l_osm_fr,
      "OpenStreetMap Humanitarian": l_osm_hot,
      "EOX OSM": l_eox_osm,
      "EOX Black Marble": l_eox_blackmarble,
      "EOX Blue Marble": l_eox_bluemarble,
      "EOX Sentinel-2 2020": l_eox_sentinel2_2020,
      "EOX Sentinel-2 2019": l_eox_sentinel2_2019,
      "EOX Sentinel-2 2018": l_eox_sentinel2_2018,
      "EOX Terrain": l_eox_terrain,
      "EOX Terrain (Light)": l_eox_terrain_light,
      "USGS Imagery": l_usgs_img,
      "USGS Topo": g_usgs_topo,
      "USGS Imagery + Topo": l_usgs_imgtopo,
      //"USGS Relief": l_usgs_relief,
      "USGS Hillshade (US, CA, MX)": l_usgs_3dep_hillshade,
      "USGS Aspect (US, CA, MX)": l_usgs_3dep_aspect,
      "USGS Slope (US, CA, MX)": l_usgs_3dep_slope,
   };

   // define available overlay maps (can view more than one at a time, arranged in order from lowest to highest)
   var overlaymaps = {
      "USGS Ecological Land Units": l_usgs_ecolandunit,
      "USGS Hydro": l_usgs_hydro,
      "EOX Hydrography": l_eox_hydrography,
      "USGS Contours (US only)": l_usgs_3dep_contours,
      //"USGS Trasnportation": l_usgs_3dep_transport,
      //"Stamen Terrain Lines": l_stamen_terrainlines,
      //"Stamen Toner Lines": l_stamen_tonerlines,
      //"Stamen Toner Hybrid": l_stamen_tonerhybrid,
      //"Stamen Terrain Labels": l_stamen_terrainlabels,
      //"Stamen Toner Labels": l_stamen_tonerlabels,
      "EOX Streets": l_eox_streets,
      "EOX Coastline": l_eox_coastline,
      "EOX Overlay": l_eox_overlay,
      "EOX Overlay (Bright)": l_eox_overlay_bright,
      ...((taxon_id==null) ? {} : {"iNaturalist Taxon Range": l_inat_taxonrange}),
      ...((taxon_id==null) ? {} : {"iNaturalist Taxon Places": l_inat_taxonplace}),
      ...((place_id==null) ? {} : {"iNaturalist Place": l_inat_place}),
      ...((compexclparam==null) ? {} : {"iNaturalist Subset Ratio (Red=1.0, Blue=0.0)": l_utfgrid_compare}),
      //"iNaturalist Observations Density in GBIF (no filters)": l_gbif,
      "iNaturalist Observations Heatmap": l_inat_heat,
      "iNaturalist Observations Heatmap Mod (Transparent)": l_inat_heat_mod_transparent,
      //"iNaturalist Observations Circles": l_inat_circles,
      "iNaturalist Observations Grid": l_inat_grid,
      "iNaturalist Observations Points": l_inat_points,
      "iNaturalist Observations":g_inat_obs,
      "iNaturalist Observation Info":g_utfgdm_sel,
      "iNaturalist Observation Info for Grid":g_utfgdm_sel_grid,
      ...((compexclparam==null) ? {} : {"iNaturalist Observation Info for Superset Grid": g_utfgdm_sel_superset}),
      "iNaturalist Observation Info for Points":g_utfgdm_sel_points,
      "Graticule":l_graticule,
      "Debug Grid":l_debug,
   };

   var mymap;
   // if centerlat, centerlng, or defaultzoom are specified, then use that user-specified value
   // otherwise, set map extent based on coverage of observations
   let prom = (centerlat===null && centerlng===null && defaultzoom===null) ? ffetch(inat_urlbase+'observations?return_bounds=true&per_page=0&'+winurlparams) : Promise.resolve(null);
   prom.then((data) => {
      return data?.total_bounds;
   })
   .then((bbox) => {
      // create map, and set default center coordinates, zoom level, and layers
      mymap = L.map('mapid', {
         center: [centerlat||0,centerlng||0], // default to lat 0, long 0
         zoom: defaultzoom??2, // iNat defaults to zoom level 2
         layers: defaultlayers,
         doubleClickZoom: false
      });
      if (bbox) {
         var bounds = [[bbox.nelat,(bbox.swlng<bbox.nelng?bbox.nelng:bbox.nelng+360)],[bbox.swlat,bbox.swlng]];
         var padding = {padding:[5,5]};
         mymap.fitBounds(bounds,padding);
      };
      // add a layer selector control and scale bar
      L.control.layers(basemaps, overlaymaps).addTo(mymap);
      L.control.scale().addTo(mymap);
   });
};

</script>
</body>
</html>