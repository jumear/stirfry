<!DOCTYPE html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0" />
<meta name="description" content="iNaturalist API Get Observations Taxonomy" />
<title>iNaturalist API Get Observations Taxonomy</title>
<style>
   :root {
      background: var(--color-base);
      color: var(--color-text);
      font: 14px Sans-Serif;
      --color-base: white;
      --color-alt: whitesmoke;
      --color-brand: forestgreen;
      --color-text: black;
      --color-text-invert: white;
      --color-text-link: royalblue;
      --color-border: lightgray;
      --color-hover: lightgray;
      --color-base-translucent: rgba(255,255,255,0.85);
   }
   @media (prefers-color-scheme: dark) {
      :root {
         --color-base: black;
         --color-alt: #171717;
         --color-brand: forestgreen;
         --color-text: #bababa;
         --color-text-invert: black;
         --color-text-link: cornflowerblue;
         --color-border: #444;
         --color-hover: #444;
         --color-base-translucent: rgba(0,0,0,0.85);
      }
   }
   #main { width:100%; }
   table, td, th { border-collapse:collapse; margin:0; padding:4px; }
   th { position:-webkit-sticky /*Safari*/; position:sticky; top:0; font-weight:600; background:var(--color-brand); color:var(--color-text-invert); text-align:left; vertical-align:bottom; }
   tbody>tr { border-width:1px 0px; border-style:solid; border-color:var(--color-border); background:var(--color-alt);}
   tr:nth-child(even) { background:var(--color-base); }
   .tar { text-align:right; }
   a { text-decoration:none; color:var(--color-text-link); }
   a:hover { background:var(--color-hover); }
   #nav { margin-left:-8px; position:-webkit-sticky /*Safari*/; position:sticky; left:0; bottom:0; background:var(--color-base-translucent); width:188px; height:52px; border-radius:14px; }
   @media print { #nav { display:none; } } 
   .nowrap { white-space: nowrap; }
</style>
</head>

<body>
<script>
let winurlstr = window.location.href;
let winurlsearchstr = window.location.search;
let winurlexsearchstr = winurlstr.replace(winurlsearchstr,'');
let winurlparams = new URLSearchParams(winurlsearchstr.substring(1));
let p_options = winurlparams.get('options') || [];
winurlparams.delete('options');

function furl(url,txt=url) { return '<a href="'+url+'">'+txt+'</a>'; };
function famp(str) { return str.replace(/&/g,'&amp;'); };
function fcomnum(n) { return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g,',') };
function fpct(d,p=1) {
   x = d*100;
   return x.toFixed(p);
};
function faddelem(etype,eparent=null,eattributes={}) {
   let eobj = document.createElement(etype);
   for (let [key,value] of Object.entries(eattributes)) {
      if ( typeof value === 'object' && value !== null ) {
         for (let [subkey,subvalue] of Object.entries(value)) { eobj[key][subkey] = subvalue; };
      }
      else { eobj[key] = value; };
    };
   if (eparent) { eparent.appendChild(eobj); };
   return eobj;
};
function faddelems(etype,eparent=null,eattributes=[]) { for (let e of eattributes) { faddelem(etype,eparent,e); }; };

const special_taxon_id = { life:48460, allobs:-1, unknown:0 };

function fdata(xobj) {
  let taxa = xobj.results
  let taxon_life = taxa.filter(r=>r.id===special_taxon_id.life)[0];
  let count_unknown = xobj.count_without_taxon ? xobj.count_without_taxon-taxon_life.direct_obs_count : 0;  
  
  // add a new top-level parent node to represent all observations
  let taxon_allobs = {
    id:special_taxon_id.allobs,
    count:0,
    name:'(all observations)',
    rank:'stateofmatter',
    rank_level:101,
    is_active:true,
    parent_id:null,
    descendant_obs_count:taxon_life.descendant_obs_count+count_unknown,
    direct_obs_count:0,
    descendant_obs_count_pct:1.0,
    seq:1,
    tree:[],
  }
  taxa.push(taxon_allobs);
  
  // if true unknowns exist, add a node for that
  if (count_unknown) {
    taxa.push({
      id:special_taxon_id.unknown,
      count:count_unknown,
      name:'(unknown taxon)',
      rank:'stateofmatter',
      rank_level:100,
      is_active:true,
      parent_id:special_taxon_id.allobs,
      descendant_obs_count:count_unknown,
      direct_obs_count:count_unknown,
      descendant_obs_count_pct:count_unknown/taxon_allobs.descendant_obs_count,
    });
  };
  
  // make the original life node a child of all observations  
  taxon_life['parent_id']=special_taxon_id.allobs;

  // main function for taxonomic sort
  // first, sort by name asc
  // then sequence the taxa and create a hierarchical tree representation

  taxa.sort((a,b)=>(a.name<b.name?-1:1));
  //taxa.sort((a,b)=>(b.rank_level-a.rank_level));
  
  function fchildtaxa(parent_id,tree=[],ancestry=[]) {
    let children = taxa.filter(r=>r.parent_id===parent_id);
    //let children = pid_to_i[parent_id.toString()];
    for (let c=0; (children && c<children.length); c++) {
      sort_seq++
      child_tree = [...tree,(c+1===children.length?1:0)]
      child = children[c];
      //child = taxa[children[c]]; 
      child['descendant_obs_count_pct'] = child.descendant_obs_count/taxon_allobs.descendant_obs_count,
      child['seq'] = sort_seq;
      child['tree'] = child_tree;
      if (p_options.includes('ancestry')) {
        child_ancestry = (parent_id > 0) ? [...ancestry,parent_id] : ancestry;
        child['ancestry'] = child_ancestry;
        fchildtaxa(child.id,child_tree,child_ancestry);
      }
      else { fchildtaxa(child.id,child_tree); };
    };
    return (children ? children.length : 0);
  };
  let sort_seq = 1;
  fchildtaxa(special_taxon_id.allobs);
  taxa.sort((a,b)=>(a.seq-b.seq));

  // this creates a textual representation of a tree diagram using UTF-8 symbols
  for (let t of taxa) {
     let tree_text = '';
     let tree = t.tree;
     for (let i=0; i<tree.length; i++) {
        if (i+1===tree.length) {tree_text += (tree[i]?String.fromCharCode(9492):String.fromCharCode(9500)); } // the connector just before the node will either be ‚îî (an up + right connector) or ‚îú (a vertical + right connector)
        else {tree_text += (tree[i]?String.fromCharCode(8199):String.fromCharCode(9474)); }; // all other connectors will either be ‚Äá (blank) or ‚îÇ (a vertical connector)
     };
     t['tree_text'] = tree_text + ( // the node
        (t.id===special_taxon_id.allobs) ? String.fromCharCode(11044) : // base node = ‚¨§ (filled circle)
        (t.id===special_taxon_id.unknown) ? String.fromCharCode(11198) : // unknown node = ‚Ææ (circle with x)
        (t.id===special_taxon_id.life) ? String.fromCharCode(11095) : // life node = ‚≠ó (circle with inner circle)
        (t.rank_level===70) ? String.fromCharCode(11203) : // kingdom level = ‚ØÉ (filled octagon)
        (t.rank_level===60) ? String.fromCharCode(11042) : // phylum level = ‚¨¢ (filled hexagon)
        (t.rank_level>50) ? String.fromCharCode(11041) : // between phylum and class = ‚¨° (hexagon)
        (t.rank_level===50) ? String.fromCharCode(11039) : // class level = ‚¨ü (filled pentagon)
        (t.rank_level>40) ? String.fromCharCode(11040) : // between class and order = ‚¨† (pentagon) 
        (t.rank_level===40) ? String.fromCharCode(11091) : // order level = ‚≠ì (rotated filled pentagon)
        (t.rank_level>30) ? String.fromCharCode(11092) : // between order and family = ‚≠î (rotated pentagon)
        (t.rank_level===30) ? String.fromCharCode(9724) : // family level = ‚óº (filled square)
        (t.rank_level>20) ? String.fromCharCode(9723) : // between family and genus = ‚óª (square)
        (t.rank_level===20) ? String.fromCharCode(9670) : // genus level = ‚óÜ (filled diamond)
        (t.rank_level>10) ? String.fromCharCode(9671) : // between genus and species = ‚óá (diamond)
        (t.rank_level===10) ? String.fromCharCode(9733) : // species level = ‚òÖ (filled star)
        (t.rank_level<10) ? String.fromCharCode(9734) : // subspecies level = ‚òÜ (star)
        String.fromCharCode(11096) // other = ‚≠ò (circle)
     );
  };

  return taxa;
};

function fresults(xobj) {
   if ((xobj?.results?.length??0) === 0) {
      faddelem('p',document.body,{innerText:'No results returned.'});
      return;
   };
   let results = fdata(xobj);
   let total_results = results.length;
   faddelem('p',document.body,{innerHTML:'total nodes: '+fcomnum(total_results)});
   let table = faddelem('table',document.body,{id:'main'});
   let thead = faddelem('thead',table);
   let hrow = faddelem('tr',thead);
   let labels = [
      {innerText:'Seq'},
      //{innerText:'Hierarchy'},
      {innerText:'Tree'},
      {innerText:'Name'},
      {innerText:'Rank'},
      //{innerText:'Rank Level'},
      //{innerText:'Active'},
      {innerText:'Parent ID'},
      {innerText:'ID'},
      //{classList:'tar',innerText:'Count'},
      {classList:'tar',innerText:'Obs Count'},
      {classList:'tar',innerText:'% of All Obs'},
      {classList:'tar',innerText:'Exact Taxon Obs Count'},
   ];
   if (p_options.includes('ancestry')) {labels = [...labels.slice(0,6),{innerText:'Ancestry'},...labels.slice(6)]; };
   if (p_options.includes('species')) {labels = [...labels.slice(0,3),{innerText:'"Species"'},...labels.slice(3)]; };
   if (p_options.includes('leaf')) {labels = [...labels.slice(0,3),{innerText:'"Leaf"'},...labels.slice(3)]; };
   faddelems('th',hrow,labels);

   let tbody = faddelem('tbody',table);
   for (let i=0; i<results.length; i++) {
      let brow = faddelem('tr',tbody);
      let rec = results[i];
      let values = [
         {innerText:i+1},
         //{innerText:rec.tree.join('')},
         {classList:'nowrap',innerText:rec.tree_text},
         {classList:'nowrap',innerText:rec.name},
         {innerText:rec.rank},
         //{innerText:rec.rank_level},
         //{innerText:rec.is_active},
         {innerText:rec.parent_id},
         {innerHTML:(rec.id<=0)?rec.id:furl(`https://www.inaturalist.org/taxa/${rec.id}`,rec.id)},
         {classList:'tar',innerText:fcomnum(rec.descendant_obs_count)},
         {classList:'tar',innerText:fpct(rec.descendant_obs_count_pct,3)},
         {classList:'tar',innerText:rec.direct_obs_count?fcomnum(rec.direct_obs_count):'-'},
      ];
      if (p_options.includes('ancestry')) {values = [...values.slice(0,6),{innerText: (rec.id <= 0) ? '' : [...rec.ancestry,rec.id].join('/')??''},...values.slice(6)]; };
      if (p_options.includes('species')) {values = [...values.slice(0,3),{innerText: (rec.rank_level == 10) ? 'üçÇ' : ''},...values.slice(3)]; };
      if (p_options.includes('leaf')) {values = [...values.slice(0,3),{innerText: (rec.rank_level < 100 && (rec.rank_level === 10 || (rec.rank_level > 10 && rec.direct_obs_count === rec.descendant_obs_count)) ) ? 'üçÉ' : ''},...values.slice(3)]; };
      faddelems('td',brow,values);
   };
};
let apibase = 'https://api.inaturalist.org/v1/observations/taxonomy';
let apiurl = apibase+((winurlparams!='')?('?'+winurlparams):'');
let apirefurl = 'https://api.inaturalist.org/v1/docs/#!/Observations/get_observations_taxonomy';
let apirefname = 'iNaturalist Observations Taxonomy';
let apiref = furl(apirefurl,apirefname);
faddelem('h1',document.body,{innerText:apirefname});

if (winurlsearchstr==='') {
   let instructions = [
      {innerHTML:`This page displays the response from an undocumented ${apirefname} API endpoint (which provides some of the data for the Dynamic Life List page) in a human-readable format, with some modifications to present the data more completely. To use this page, add at least one query parameter to the URL. Although ${apirefname} is undocumented, the query parameters for it should be similar to those documented for ${furl(apirefurl,'iNaturalist Observations')}.`},
      {innerHTML:'Suppose the address of this page is '+winurlexsearchstr+', <br />and you want to see the results of '+furl(famp(apibase+'?user_id=pisum&taxon_id=47126'))+' in a friendly format, <br />then you would open '+furl(famp(winurlexsearchstr+'?user_id=pisum&taxon_id=47126'))+' in your browser.'},
      {innerHTML:`There is a special parameter "options" which accepts "leaf", "species", "ancestry", or all values (separated by a comma). When "leaf" is passed, a column will be added that identifies taxa that are considered "leaves" in iNaturalist. When "species" is passed, a column will added that identifies taxa that are considered "species". When "ancestry" is passed, a column will be added to show the ancestry chain for each taxon. Here's an example page that will show these columns for a particular user's taxa: ${furl(famp(winurlexsearchstr+'?user_id=pisum&options=leaf,species,ancestry'))}.`},
      {innerHTML:`Depending on your browser and system capabilities, you may run into problems rendering the data if your query returns too many taxa. So make sure you apply enough filters to return a reasonably small result set.`},
   ];
   faddelems('p',document.body,instructions);
}
else {
   faddelem('p',document.body,{innerHTML:`This is the base query: ${furl(famp(apiurl))}. (This page will accept most parameters from the ${furl(apirefurl,'iNaturalist Observations')} API endpoint.)`});
   fetch(apiurl)
   .then((response) => {
      if (!response.ok) { throw new Error(response.status+' ('+response.statusText+') returned from '+response.url); };
      return response.json();
   })
   .then((data) => { fresults(data); })
   .catch((err) => {
      console.error(err.message);
      faddelem('p',document.body,{innerText:'There was a problem retrieving data. Error '+err.message+'.'});
   });
};

</script>
</body>

</html>